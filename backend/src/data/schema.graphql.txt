type Query {
  accountById(_id: MongoID!): Account
  accountByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsAccountInput): [Account!]!
  accountOne(
    """Filter by fields"""
    filter: FilterFindOneAccountInput
    skip: Int
    sort: SortFindOneAccountInput
  ): Account
  accountMany(
    """Filter by fields"""
    filter: FilterFindManyAccountInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyAccountInput
  ): [Account!]!
  accountCount(
    """Filter by fields"""
    filter: FilterCountAccountInput
  ): Int
  accountConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyAccountInput

    """Sort argument for data ordering"""
    sort: SortConnectionAccountEnum = _ID_DESC
  ): AccountConnection
  accountPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyAccountInput
    sort: SortFindManyAccountInput
  ): AccountPagination
  adjustmentById(_id: MongoID!): Adjustment
  adjustmentByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsAdjustmentInput): [Adjustment!]!
  adjustmentOne(
    """Filter by fields"""
    filter: FilterFindOneAdjustmentInput
    skip: Int
    sort: SortFindOneAdjustmentInput
  ): Adjustment
  adjustmentMany(
    """Filter by fields"""
    filter: FilterFindManyAdjustmentInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyAdjustmentInput
  ): [Adjustment!]!
  adjustmentCount(
    """Filter by fields"""
    filter: FilterCountAdjustmentInput
  ): Int
  adjustmentConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyAdjustmentInput

    """Sort argument for data ordering"""
    sort: SortConnectionAdjustmentEnum = _ID_DESC
  ): AdjustmentConnection
  adjustmentPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyAdjustmentInput
    sort: SortFindManyAdjustmentInput
  ): AdjustmentPagination
  AdjustmentWarehouseResolver: Adjustment
  adjustmentProductAdjustmentsResolver: Adjustment
  attributeById(_id: MongoID!): Attribute
  attributeByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsAttributeInput): [Attribute!]!
  attributeOne(
    """Filter by fields"""
    filter: FilterFindOneAttributeInput
    skip: Int
    sort: SortFindOneAttributeInput
  ): Attribute
  attributeMany(
    """Filter by fields"""
    filter: FilterFindManyAttributeInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyAttributeInput
  ): [Attribute!]!
  attributeCount(
    """Filter by fields"""
    filter: FilterCountAttributeInput
  ): Int
  attributeConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyAttributeInput

    """Sort argument for data ordering"""
    sort: SortConnectionAttributeEnum = _ID_DESC
  ): AttributeConnection
  attributePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyAttributeInput
    sort: SortFindManyAttributeInput
  ): AttributePagination
  attributeValuesResolver: Attribute
  brandById(_id: MongoID!): Brand
  brandByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsBrandInput): [Brand!]!
  brandOne(
    """Filter by fields"""
    filter: FilterFindOneBrandInput
    skip: Int
    sort: SortFindOneBrandInput
  ): Brand
  brandMany(
    """Filter by fields"""
    filter: FilterFindManyBrandInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyBrandInput
  ): [Brand!]!
  brandCount(
    """Filter by fields"""
    filter: FilterCountBrandInput
  ): Int
  brandConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyBrandInput

    """Sort argument for data ordering"""
    sort: SortConnectionBrandEnum = _ID_DESC
  ): BrandConnection
  brandPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyBrandInput
    sort: SortFindManyBrandInput
  ): BrandPagination
  categoryById(_id: MongoID!): Category
  categoryByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsCategoryInput): [Category!]!
  categoryOne(
    """Filter by fields"""
    filter: FilterFindOneCategoryInput
    skip: Int
    sort: SortFindOneCategoryInput
  ): Category
  categoryMany(
    """Filter by fields"""
    filter: FilterFindManyCategoryInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyCategoryInput
  ): [Category!]!
  categoryCount(
    """Filter by fields"""
    filter: FilterCountCategoryInput
  ): Int
  categoryConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyCategoryInput

    """Sort argument for data ordering"""
    sort: SortConnectionCategoryEnum = _ID_DESC
  ): CategoryConnection
  categoryPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyCategoryInput
    sort: SortFindManyCategoryInput
  ): CategoryPagination
  couponById(_id: MongoID!): Coupon
  couponByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsCouponInput): [Coupon!]!
  couponOne(
    """Filter by fields"""
    filter: FilterFindOneCouponInput
    skip: Int
    sort: SortFindOneCouponInput
  ): Coupon
  couponMany(
    """Filter by fields"""
    filter: FilterFindManyCouponInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyCouponInput
  ): [Coupon!]!
  couponCount(
    """Filter by fields"""
    filter: FilterCountCouponInput
  ): Int
  couponConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyCouponInput

    """Sort argument for data ordering"""
    sort: SortConnectionCouponEnum = _ID_DESC
  ): CouponConnection
  couponPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyCouponInput
    sort: SortFindManyCouponInput
  ): CouponPagination
  couponUserResolver: Coupon
  customerById(_id: MongoID!): Customer
  customerByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsCustomerInput): [Customer!]!
  customerOne(
    """Filter by fields"""
    filter: FilterFindOneCustomerInput
    skip: Int
    sort: SortFindOneCustomerInput
  ): Customer
  customerMany(
    """Filter by fields"""
    filter: FilterFindManyCustomerInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyCustomerInput
  ): [Customer!]!
  customerCount(
    """Filter by fields"""
    filter: FilterCountCustomerInput
  ): Int
  customerConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyCustomerInput

    """Sort argument for data ordering"""
    sort: SortConnectionCustomerEnum = _ID_DESC
  ): CustomerConnection
  customerPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyCustomerInput
    sort: SortFindManyCustomerInput
  ): CustomerPagination
  customerGroupResolver: Customer
  customerUserResolver: Customer
  customerGroupById(_id: MongoID!): Customer_Group
  customerGroupByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsCustomer_GroupInput): [Customer_Group!]!
  customerGroupOne(
    """Filter by fields"""
    filter: FilterFindOneCustomer_GroupInput
    skip: Int
    sort: SortFindOneCustomer_GroupInput
  ): Customer_Group
  customerGroupMany(
    """Filter by fields"""
    filter: FilterFindManyCustomer_GroupInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyCustomer_GroupInput
  ): [Customer_Group!]!
  customerGroupCount(
    """Filter by fields"""
    filter: FilterCountCustomer_GroupInput
  ): Int
  customerGroupConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyCustomer_GroupInput

    """Sort argument for data ordering"""
    sort: SortConnectionCustomer_GroupEnum = _ID_DESC
  ): Customer_GroupConnection
  customerGroupPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyCustomer_GroupInput
    sort: SortFindManyCustomer_GroupInput
  ): Customer_GroupPagination
  departmentById(_id: MongoID!): Department
  departmentByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsDepartmentInput): [Department!]!
  departmentOne(
    """Filter by fields"""
    filter: FilterFindOneDepartmentInput
    skip: Int
    sort: SortFindOneDepartmentInput
  ): Department
  departmentMany(
    """Filter by fields"""
    filter: FilterFindManyDepartmentInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyDepartmentInput
  ): [Department!]!
  departmentCount(
    """Filter by fields"""
    filter: FilterCountDepartmentInput
  ): Int
  departmentConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyDepartmentInput

    """Sort argument for data ordering"""
    sort: SortConnectionDepartmentEnum = _ID_DESC
  ): DepartmentConnection
  departmentPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyDepartmentInput
    sort: SortFindManyDepartmentInput
  ): DepartmentPagination
  EmployeeById(_id: MongoID!): Employee
  EmployeeByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsEmployeeInput): [Employee!]!
  EmployeeOne(
    """Filter by fields"""
    filter: FilterFindOneEmployeeInput
    skip: Int
    sort: SortFindOneEmployeeInput
  ): Employee
  EmployeeMany(
    """Filter by fields"""
    filter: FilterFindManyEmployeeInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyEmployeeInput
  ): [Employee!]!
  EmployeeCount(
    """Filter by fields"""
    filter: FilterCountEmployeeInput
  ): Int
  EmployeeConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyEmployeeInput

    """Sort argument for data ordering"""
    sort: SortConnectionEmployeeEnum = _ID_DESC
  ): EmployeeConnection
  EmployeePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyEmployeeInput
    sort: SortFindManyEmployeeInput
  ): EmployeePagination
  EmployeeRoleResolver: Employee
  EmployeePersonnelResolver: Employee
  EmployeePayrollResolver: Employee
  productAdjustmentById(_id: MongoID!): Product_Adjustment
  productAdjustmentByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_AdjustmentInput): [Product_Adjustment!]!
  productAdjustmentOne(
    """Filter by fields"""
    filter: FilterFindOneProduct_AdjustmentInput
    skip: Int
    sort: SortFindOneProduct_AdjustmentInput
  ): Product_Adjustment
  productAdjustmentMany(
    """Filter by fields"""
    filter: FilterFindManyProduct_AdjustmentInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProduct_AdjustmentInput
  ): [Product_Adjustment!]!
  productAdjustmentCount(
    """Filter by fields"""
    filter: FilterCountProduct_AdjustmentInput
  ): Int
  productAdjustmentConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProduct_AdjustmentInput

    """Sort argument for data ordering"""
    sort: SortConnectionProduct_AdjustmentEnum = _ID_DESC
  ): Product_AdjustmentConnection
  productAdjustmentPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProduct_AdjustmentInput
    sort: SortFindManyProduct_AdjustmentInput
  ): Product_AdjustmentPagination
  ProductAdjustmentProductResolver: Product_Adjustment
  ProductAdjustmentVariantIDResolver: Product_Adjustment
  productPurchaseById(_id: MongoID!): Product_Purchase
  productPurchaseByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_PurchaseInput): [Product_Purchase!]!
  productPurchaseOne(
    """Filter by fields"""
    filter: FilterFindOneProduct_PurchaseInput
    skip: Int
    sort: SortFindOneProduct_PurchaseInput
  ): Product_Purchase
  productPurchaseMany(
    """Filter by fields"""
    filter: FilterFindManyProduct_PurchaseInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProduct_PurchaseInput
  ): [Product_Purchase!]!
  productPurchaseCount(
    """Filter by fields"""
    filter: FilterCountProduct_PurchaseInput
  ): Int
  productPurchaseConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProduct_PurchaseInput

    """Sort argument for data ordering"""
    sort: SortConnectionProduct_PurchaseEnum = _ID_DESC
  ): Product_PurchaseConnection
  productPurchasePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProduct_PurchaseInput
    sort: SortFindManyProduct_PurchaseInput
  ): Product_PurchasePagination
  productPurchasePurchaseResolver: Product_Purchase
  productPurchaseUnitResolver: Product_Purchase
  productPurchaseVariantResolver: Product_Purchase
  productQuotationById(_id: MongoID!): Product_Quotation
  productQuotationByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_QuotationInput): [Product_Quotation!]!
  productQuotationOne(
    """Filter by fields"""
    filter: FilterFindOneProduct_QuotationInput
    skip: Int
    sort: SortFindOneProduct_QuotationInput
  ): Product_Quotation
  productQuotationMany(
    """Filter by fields"""
    filter: FilterFindManyProduct_QuotationInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProduct_QuotationInput
  ): [Product_Quotation!]!
  productQuotationCount(
    """Filter by fields"""
    filter: FilterCountProduct_QuotationInput
  ): Int
  productQuotationConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProduct_QuotationInput

    """Sort argument for data ordering"""
    sort: SortConnectionProduct_QuotationEnum = _ID_DESC
  ): Product_QuotationConnection
  productQuotationPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProduct_QuotationInput
    sort: SortFindManyProduct_QuotationInput
  ): Product_QuotationPagination
  productQuotationResolver: Product_Quotation
  productQuotationUnitResolver: Product_Quotation
  productQuotationVariantResolver: Product_Quotation
  productReturnById(_id: MongoID!): Product_Return
  productReturnByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_ReturnInput): [Product_Return!]!
  productReturnOne(
    """Filter by fields"""
    filter: FilterFindOneProduct_ReturnInput
    skip: Int
    sort: SortFindOneProduct_ReturnInput
  ): Product_Return
  productReturnMany(
    """Filter by fields"""
    filter: FilterFindManyProduct_ReturnInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProduct_ReturnInput
  ): [Product_Return!]!
  productReturnCount(
    """Filter by fields"""
    filter: FilterCountProduct_ReturnInput
  ): Int
  productReturnConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProduct_ReturnInput

    """Sort argument for data ordering"""
    sort: SortConnectionProduct_ReturnEnum = _ID_DESC
  ): Product_ReturnConnection
  productReturnPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProduct_ReturnInput
    sort: SortFindManyProduct_ReturnInput
  ): Product_ReturnPagination
  productReturnResolver: Product_Return
  productReturnUnitResolver: Product_Return
  productReturnVariantResolver: Product_Return
  productSaleById(_id: MongoID!): Product_Sale
  productSaleByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_SaleInput): [Product_Sale!]!
  productSaleOne(
    """Filter by fields"""
    filter: FilterFindOneProduct_SaleInput
    skip: Int
    sort: SortFindOneProduct_SaleInput
  ): Product_Sale
  productSaleMany(
    """Filter by fields"""
    filter: FilterFindManyProduct_SaleInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProduct_SaleInput
  ): [Product_Sale!]!
  productSaleCount(
    """Filter by fields"""
    filter: FilterCountProduct_SaleInput
  ): Int
  productSaleConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProduct_SaleInput

    """Sort argument for data ordering"""
    sort: SortConnectionProduct_SaleEnum = _ID_DESC
  ): Product_SaleConnection
  productSalePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProduct_SaleInput
    sort: SortFindManyProduct_SaleInput
  ): Product_SalePagination
  productSaleResolver: Product_Sale
  productSaleUnitResolver: Product_Sale
  productSaleVariantResolver: Product_Sale
  productSupplierById(_id: MongoID!): Product_Supplier
  productSupplierByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_SupplierInput): [Product_Supplier!]!
  productSupplierOne(
    """Filter by fields"""
    filter: FilterFindOneProduct_SupplierInput
    skip: Int
    sort: SortFindOneProduct_SupplierInput
  ): Product_Supplier
  productSupplierMany(
    """Filter by fields"""
    filter: FilterFindManyProduct_SupplierInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProduct_SupplierInput
  ): [Product_Supplier!]!
  productSupplierCount(
    """Filter by fields"""
    filter: FilterCountProduct_SupplierInput
  ): Int
  productSupplierConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProduct_SupplierInput

    """Sort argument for data ordering"""
    sort: SortConnectionProduct_SupplierEnum = _ID_DESC
  ): Product_SupplierConnection
  productSupplierPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProduct_SupplierInput
    sort: SortFindManyProduct_SupplierInput
  ): Product_SupplierPagination
  productSupplierProductVariantResolver: Product_Supplier
  productSupplierSupplierResolver: Product_Supplier
  ProductTransferById(_id: MongoID!): Product_Transfer
  ProductTransferByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_TransferInput): [Product_Transfer!]!
  ProductTransferOne(
    """Filter by fields"""
    filter: FilterFindOneProduct_TransferInput
    skip: Int
    sort: SortFindOneProduct_TransferInput
  ): Product_Transfer
  ProductTransferMany(
    """Filter by fields"""
    filter: FilterFindManyProduct_TransferInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProduct_TransferInput
  ): [Product_Transfer!]!
  ProductTransferCount(
    """Filter by fields"""
    filter: FilterCountProduct_TransferInput
  ): Int
  ProductTransferConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProduct_TransferInput

    """Sort argument for data ordering"""
    sort: SortConnectionProduct_TransferEnum = _ID_DESC
  ): Product_TransferConnection
  ProductTransferPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProduct_TransferInput
    sort: SortFindManyProduct_TransferInput
  ): Product_TransferPagination
  ProductTransferPurchaseResolver: Product_Transfer
  ProductTransferUnitResolver: Product_Transfer
  ProductTransferVariantResolver: Product_Transfer
  productVariantById(_id: MongoID!): Product_Variant
  productVariantByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_VariantInput): [Product_Variant!]!
  productVariantOne(
    """Filter by fields"""
    filter: FilterFindOneProduct_VariantInput
    skip: Int
    sort: SortFindOneProduct_VariantInput
  ): Product_Variant
  productVariantMany(
    """Filter by fields"""
    filter: FilterFindManyProduct_VariantInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProduct_VariantInput
  ): [Product_Variant!]!
  productVariantCount(
    """Filter by fields"""
    filter: FilterCountProduct_VariantInput
  ): Int
  productVariantConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProduct_VariantInput

    """Sort argument for data ordering"""
    sort: SortConnectionProduct_VariantEnum = _ID_DESC
  ): Product_VariantConnection
  productVariantPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProduct_VariantInput
    sort: SortFindManyProduct_VariantInput
  ): Product_VariantPagination
  ProductVariantProductResolver: Product_Variant
  ProductVariantVariantIDResolver: Product_Variant
  ProductVariantUnitResolver: Product_Variant
  ProductVariantCategoryResolver: Product_Variant
  ProductVariantSuppliersResolver: Product_Variant
  ProductVariantPurchaseUnitResolver: Product_Variant
  ProductVariantSaleUnitResolver: Product_Variant
  productWarehouseById(_id: MongoID!): Product_Warehouse
  productWarehouseByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_WarehouseInput): [Product_Warehouse!]!
  productWarehouseOne(
    """Filter by fields"""
    filter: FilterFindOneProduct_WarehouseInput
    skip: Int
    sort: SortFindOneProduct_WarehouseInput
  ): Product_Warehouse
  productWarehouseMany(
    """Filter by fields"""
    filter: FilterFindManyProduct_WarehouseInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProduct_WarehouseInput
  ): [Product_Warehouse!]!
  productWarehouseCount(
    """Filter by fields"""
    filter: FilterCountProduct_WarehouseInput
  ): Int
  productWarehouseConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProduct_WarehouseInput

    """Sort argument for data ordering"""
    sort: SortConnectionProduct_WarehouseEnum = _ID_DESC
  ): Product_WarehouseConnection
  productWarehousePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProduct_WarehouseInput
    sort: SortFindManyProduct_WarehouseInput
  ): Product_WarehousePagination
  productWarehouseProductResolver: Product_Warehouse
  productWarehouseVariantIDResolver: Product_Warehouse
  productById(_id: MongoID!): Product
  productByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProductInput): [Product!]!
  productOne(
    """Filter by fields"""
    filter: FilterFindOneProductInput
    skip: Int
    sort: SortFindOneProductInput
  ): Product
  productMany(
    """Filter by fields"""
    filter: FilterFindManyProductInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyProductInput
  ): [Product!]!
  productCount(
    """Filter by fields"""
    filter: FilterCountProductInput
  ): Int
  productConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyProductInput

    """Sort argument for data ordering"""
    sort: SortConnectionProductEnum = _ID_DESC
  ): ProductConnection
  productPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyProductInput
    sort: SortFindManyProductInput
  ): ProductPagination
  purchaseById(_id: MongoID!): Purchase
  purchaseByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsPurchaseInput): [Purchase!]!
  purchaseOne(
    """Filter by fields"""
    filter: FilterFindOnePurchaseInput
    skip: Int
    sort: SortFindOnePurchaseInput
  ): Purchase
  purchaseMany(
    """Filter by fields"""
    filter: FilterFindManyPurchaseInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyPurchaseInput
  ): [Purchase!]!
  purchaseCount(
    """Filter by fields"""
    filter: FilterCountPurchaseInput
  ): Int
  purchaseConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyPurchaseInput

    """Sort argument for data ordering"""
    sort: SortConnectionPurchaseEnum = _ID_DESC
  ): PurchaseConnection
  purchasePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyPurchaseInput
    sort: SortFindManyPurchaseInput
  ): PurchasePagination
  purchaseWarehouseResolver: Purchase
  purchaseSupplierResolver: Purchase
  purchaseUserResolver: Purchase
  purchaseProductPurchasesResolver: Purchase
  purchaseProductPurchaseReturnsResolver: Purchase
  quotationById(_id: MongoID!): Quotation
  quotationByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsQuotationInput): [Quotation!]!
  quotationOne(
    """Filter by fields"""
    filter: FilterFindOneQuotationInput
    skip: Int
    sort: SortFindOneQuotationInput
  ): Quotation
  quotationMany(
    """Filter by fields"""
    filter: FilterFindManyQuotationInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyQuotationInput
  ): [Quotation!]!
  quotationCount(
    """Filter by fields"""
    filter: FilterCountQuotationInput
  ): Int
  quotationConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyQuotationInput

    """Sort argument for data ordering"""
    sort: SortConnectionQuotationEnum = _ID_DESC
  ): QuotationConnection
  quotationPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyQuotationInput
    sort: SortFindManyQuotationInput
  ): QuotationPagination
  quotationWarehouseResolver: Quotation
  quotationSupplierResolver: Quotation
  quotationUserResolver: Quotation
  quotationCustomerResolver: Quotation
  quotationBillerResolver: Quotation
  quotationProductQuotationsResolver: Quotation
  returnById(_id: MongoID!): Return
  returnByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsReturnInput): [Return!]!
  returnOne(
    """Filter by fields"""
    filter: FilterFindOneReturnInput
    skip: Int
    sort: SortFindOneReturnInput
  ): Return
  returnMany(
    """Filter by fields"""
    filter: FilterFindManyReturnInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyReturnInput
  ): [Return!]!
  returnCount(
    """Filter by fields"""
    filter: FilterCountReturnInput
  ): Int
  returnConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyReturnInput

    """Sort argument for data ordering"""
    sort: SortConnectionReturnEnum = _ID_DESC
  ): ReturnConnection
  returnPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyReturnInput
    sort: SortFindManyReturnInput
  ): ReturnPagination
  returnWarehouseResolver: Return
  returnAccountResolver: Return
  returnUserResolver: Return
  returnCustomerResolver: Return
  returnBillerResolver: Return
  returnProductReturnsResolver: Return
  roleById(_id: MongoID!): Role
  roleByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsRoleInput): [Role!]!
  roleOne(
    """Filter by fields"""
    filter: FilterFindOneRoleInput
    skip: Int
    sort: SortFindOneRoleInput
  ): Role
  roleMany(
    """Filter by fields"""
    filter: FilterFindManyRoleInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyRoleInput
  ): [Role!]!
  roleCount(
    """Filter by fields"""
    filter: FilterCountRoleInput
  ): Int
  roleConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyRoleInput

    """Sort argument for data ordering"""
    sort: SortConnectionRoleEnum = _ID_DESC
  ): RoleConnection
  rolePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyRoleInput
    sort: SortFindManyRoleInput
  ): RolePagination
  supplierById(_id: MongoID!): Supplier
  supplierByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsSupplierInput): [Supplier!]!
  supplierOne(
    """Filter by fields"""
    filter: FilterFindOneSupplierInput
    skip: Int
    sort: SortFindOneSupplierInput
  ): Supplier
  supplierMany(
    """Filter by fields"""
    filter: FilterFindManySupplierInput
    skip: Int
    limit: Int = 100
    sort: SortFindManySupplierInput
  ): [Supplier!]!
  supplierCount(
    """Filter by fields"""
    filter: FilterCountSupplierInput
  ): Int
  supplierConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManySupplierInput

    """Sort argument for data ordering"""
    sort: SortConnectionSupplierEnum = _ID_DESC
  ): SupplierConnection
  supplierPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManySupplierInput
    sort: SortFindManySupplierInput
  ): SupplierPagination
  taxById(_id: MongoID!): Tax
  taxByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsTaxInput): [Tax!]!
  taxOne(
    """Filter by fields"""
    filter: FilterFindOneTaxInput
    skip: Int
    sort: SortFindOneTaxInput
  ): Tax
  taxMany(
    """Filter by fields"""
    filter: FilterFindManyTaxInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyTaxInput
  ): [Tax!]!
  taxCount(
    """Filter by fields"""
    filter: FilterCountTaxInput
  ): Int
  taxConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyTaxInput

    """Sort argument for data ordering"""
    sort: SortConnectionTaxEnum = _ID_DESC
  ): TaxConnection
  taxPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyTaxInput
    sort: SortFindManyTaxInput
  ): TaxPagination
  transferById(_id: MongoID!): Transfer
  transferByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsTransferInput): [Transfer!]!
  transferOne(
    """Filter by fields"""
    filter: FilterFindOneTransferInput
    skip: Int
    sort: SortFindOneTransferInput
  ): Transfer
  transferMany(
    """Filter by fields"""
    filter: FilterFindManyTransferInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyTransferInput
  ): [Transfer!]!
  transferCount(
    """Filter by fields"""
    filter: FilterCountTransferInput
  ): Int
  transferConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyTransferInput

    """Sort argument for data ordering"""
    sort: SortConnectionTransferEnum = _ID_DESC
  ): TransferConnection
  transferPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyTransferInput
    sort: SortFindManyTransferInput
  ): TransferPagination
  transferToWarehouseResolver: Transfer
  transferFromWarehouseResolver: Transfer
  transferUserResolver: Transfer
  transferProductTransfersResolver: Transfer
  unitById(_id: MongoID!): Unit
  unitByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsUnitInput): [Unit!]!
  unitOne(
    """Filter by fields"""
    filter: FilterFindOneUnitInput
    skip: Int
    sort: SortFindOneUnitInput
  ): Unit
  unitMany(
    """Filter by fields"""
    filter: FilterFindManyUnitInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyUnitInput
  ): [Unit!]!
  unitCount(
    """Filter by fields"""
    filter: FilterCountUnitInput
  ): Int
  unitConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyUnitInput

    """Sort argument for data ordering"""
    sort: SortConnectionUnitEnum = _ID_DESC
  ): UnitConnection
  unitPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyUnitInput
    sort: SortFindManyUnitInput
  ): UnitPagination
  userById(_id: MongoID!): User
  userByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsUserInput): [User!]!
  userOne(
    """Filter by fields"""
    filter: FilterFindOneUserInput
    skip: Int
    sort: SortFindOneUserInput
  ): User
  userMany(
    """Filter by fields"""
    filter: FilterFindManyUserInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyUserInput
  ): [User!]!
  userCount(
    """Filter by fields"""
    filter: FilterCountUserInput
  ): Int
  userConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyUserInput

    """Sort argument for data ordering"""
    sort: SortConnectionUserEnum = _ID_DESC
  ): UserConnection
  userPagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyUserInput
    sort: SortFindManyUserInput
  ): UserPagination
  userRoleResolver: User
  userWarehousesResolver: User
  userPersonnelResolver: User
  valueById(_id: MongoID!): Value
  valueByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsValueInput): [Value!]!
  valueOne(
    """Filter by fields"""
    filter: FilterFindOneValueInput
    skip: Int
    sort: SortFindOneValueInput
  ): Value
  valueMany(
    """Filter by fields"""
    filter: FilterFindManyValueInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyValueInput
  ): [Value!]!
  valueCount(
    """Filter by fields"""
    filter: FilterCountValueInput
  ): Int
  valueConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyValueInput

    """Sort argument for data ordering"""
    sort: SortConnectionValueEnum = _ID_DESC
  ): ValueConnection
  valuePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyValueInput
    sort: SortFindManyValueInput
  ): ValuePagination
  valueAttributeResolver: Value
  warehouseById(_id: MongoID!): Warehouse
  warehouseByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsWarehouseInput): [Warehouse!]!
  warehouseOne(
    """Filter by fields"""
    filter: FilterFindOneWarehouseInput
    skip: Int
    sort: SortFindOneWarehouseInput
  ): Warehouse
  warehouseMany(
    """Filter by fields"""
    filter: FilterFindManyWarehouseInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyWarehouseInput
  ): [Warehouse!]!
  warehouseCount(
    """Filter by fields"""
    filter: FilterCountWarehouseInput
  ): Int
  warehouseConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int

    """Forward pagination argument for returning at most first edges"""
    after: String

    """Backward pagination argument for returning at most last edges"""
    last: Int

    """Backward pagination argument for returning at most last edges"""
    before: String

    """Filter by fields"""
    filter: FilterFindManyWarehouseInput

    """Sort argument for data ordering"""
    sort: SortConnectionWarehouseEnum = _ID_DESC
  ): WarehouseConnection
  warehousePagination(
    """Page number for displaying"""
    page: Int

    """"""
    perPage: Int = 20

    """Filter by fields"""
    filter: FilterFindManyWarehouseInput
    sort: SortFindManyWarehouseInput
  ): WarehousePagination
}

type Account {
  account_no: String!
  name: String!
  initial_balance: Float!
  total_Balance: Float!
  note: String
  is_default: Boolean!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

"""
The `ID` scalar type represents a unique MongoDB identifier in collection. MongoDB by default use 12-byte ObjectId value (https://docs.mongodb.com/manual/reference/bson-types/#objectid). But MongoDB also may accepts string or integer as correct values for _id field.
"""
scalar MongoID

scalar Date

enum SortFindByIdsAccountInput {
  _ID_ASC
  _ID_DESC
  ACCOUNT_NO_ASC
  ACCOUNT_NO_DESC
  NAME_ASC
  NAME_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneAccountOperatorsInput
  OR: [FilterFindOneAccountInput!]
  AND: [FilterFindOneAccountInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneAccountOperatorsInput {
  account_no: FilterFindOneAccountAccount_noOperatorsInput
  name: FilterFindOneAccountNameOperatorsInput
  note: FilterFindOneAccountNoteOperatorsInput
  _id: FilterFindOneAccount_idOperatorsInput
  createdAt: FilterFindOneAccountCreatedAtOperatorsInput
}

input FilterFindOneAccountAccount_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

"""
The string representation of JavaScript regexp. You may provide it with flags "/^abc.*/i" or without flags like "^abc.*". More info about RegExp characters and flags: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
"""
scalar RegExpAsString @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf")

input FilterFindOneAccountNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneAccountNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneAccountCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneAccountInput {
  _ID_ASC
  _ID_DESC
  ACCOUNT_NO_ASC
  ACCOUNT_NO_DESC
  NAME_ASC
  NAME_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyAccountOperatorsInput
  OR: [FilterFindManyAccountInput!]
  AND: [FilterFindManyAccountInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyAccountOperatorsInput {
  account_no: FilterFindManyAccountAccount_noOperatorsInput
  name: FilterFindManyAccountNameOperatorsInput
  note: FilterFindManyAccountNoteOperatorsInput
  _id: FilterFindManyAccount_idOperatorsInput
  createdAt: FilterFindManyAccountCreatedAtOperatorsInput
}

input FilterFindManyAccountAccount_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyAccountNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyAccountNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyAccountCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyAccountInput {
  _ID_ASC
  _ID_DESC
  ACCOUNT_NO_ASC
  ACCOUNT_NO_DESC
  NAME_ASC
  NAME_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountAccountOperatorsInput
  OR: [FilterCountAccountInput!]
  AND: [FilterCountAccountInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountAccountOperatorsInput {
  account_no: FilterCountAccountAccount_noOperatorsInput
  name: FilterCountAccountNameOperatorsInput
  note: FilterCountAccountNoteOperatorsInput
  _id: FilterCountAccount_idOperatorsInput
  createdAt: FilterCountAccountCreatedAtOperatorsInput
}

input FilterCountAccountAccount_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountAccountNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountAccountNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountAccountCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type AccountConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [AccountEdge!]!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""An edge in a connection."""
type AccountEdge {
  """The item at the end of the edge"""
  node: Account!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionAccountEnum {
  _ID_DESC
  _ID_ASC
  ACCOUNT_NO_DESC
  ACCOUNT_NO_ASC
  NAME_DESC
  NAME_ASC
  NOTE_DESC
  NOTE_ASC
}

"""List of items with pagination."""
type AccountPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Account!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type PaginationInfo {
  currentPage: Int!
  perPage: Int!
  pageCount: Int
  itemCount: Int
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

type Adjustment {
  reference_no: String!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  warehouse: Warehouse
  product_adjustments(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_AdjustmentInput): [Product_Adjustment!]!
  document: String
  note: String
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Warehouse {
  name: String!
  email: String!
  address: String!
  phone: Float!
  product_variants: [MongoID]
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
  product_variantss(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_VariantInput): [Product_Variant!]!
}

type Product_Variant {
  variant: Variant
  product: Product
  unit: Unit
  category: Category
  tax: Tax
  purchase_unit: MongoID!
  sale_unit: Unit
  productSuppliers(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_SupplierInput): [Product_Supplier!]!
  product_type: EnumProduct_VariantProduct_type!
  barcode_symbology: String!
  item_code: String!
  qty: Float!
  position: Float!
  additional_price: Float!
  alert_qty: Float
  promotion: Boolean!
  promotion_price: Float!
  price: Float!
  cost: Float!
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean!
  product_list: String
  qty_list: String
  price_list: String
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
  pruchase_unit: Unit
}

type Variant {
  name: String!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Product {
  name: String!
  code: String!
  brand: Brand
  product_variants(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_VariantInput): [Product_Variant!]!
  file: String
  product_details: String
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Brand {
  name: String!
  image: String
  products(limit: Int = 100, sort: SortFindByIdsProductInput): [Product!]!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsProductInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

enum SortFindByIdsProduct_VariantInput {
  _ID_ASC
  _ID_DESC
  VARIANT_ASC
  VARIANT_DESC
  ITEM_CODE_ASC
  ITEM_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type Unit {
  unit_name: String!
  unit_code: String!
  base_unit: String!
  operator: String!
  operation_value: Float!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Category {
  name: String!
  image: String
  variants(limit: Int = 100, sort: SortFindByIdsVariantInput): [Variant!]!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsVariantInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type Tax {
  name: String!
  rate: Float!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Product_Supplier {
  productVariant: Product_Variant
  supplier: Supplier
  qty: Float!
  price: Float!
  itemCode: String!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Supplier {
  name: String!
  image: String
  company_name: String!
  vat_number: Float
  email: String!
  phone_number: Float!
  address: String!
  city: String!
  state: String!
  postal_code: String!
  country: String!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsProduct_SupplierInput {
  _ID_ASC
  _ID_DESC
  ITEMCODE_ASC
  ITEMCODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

enum EnumProduct_VariantProduct_type {
  Standard
  Combo
  Digital
}

enum EnumProduct_VariantTax_method {
  Exclusive
  Inclusive
}

type Product_Adjustment {
  adjustment: Adjustment
  product_variant: Product_Variant
  qty: Float!
  action: String!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsProduct_AdjustmentInput {
  _ID_ASC
  _ID_DESC
  ADJUSTMENT_ASC
  ADJUSTMENT_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

enum SortFindByIdsAdjustmentInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneAdjustmentOperatorsInput
  OR: [FilterFindOneAdjustmentInput!]
  AND: [FilterFindOneAdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneAdjustmentOperatorsInput {
  reference_no: FilterFindOneAdjustmentReference_noOperatorsInput
  document: FilterFindOneAdjustmentDocumentOperatorsInput
  note: FilterFindOneAdjustmentNoteOperatorsInput
  _id: FilterFindOneAdjustment_idOperatorsInput
  createdAt: FilterFindOneAdjustmentCreatedAtOperatorsInput
}

input FilterFindOneAdjustmentReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneAdjustmentDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneAdjustmentNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneAdjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneAdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneAdjustmentInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyAdjustmentOperatorsInput
  OR: [FilterFindManyAdjustmentInput!]
  AND: [FilterFindManyAdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyAdjustmentOperatorsInput {
  reference_no: FilterFindManyAdjustmentReference_noOperatorsInput
  document: FilterFindManyAdjustmentDocumentOperatorsInput
  note: FilterFindManyAdjustmentNoteOperatorsInput
  _id: FilterFindManyAdjustment_idOperatorsInput
  createdAt: FilterFindManyAdjustmentCreatedAtOperatorsInput
}

input FilterFindManyAdjustmentReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyAdjustmentDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyAdjustmentNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyAdjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyAdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyAdjustmentInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountAdjustmentOperatorsInput
  OR: [FilterCountAdjustmentInput!]
  AND: [FilterCountAdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountAdjustmentOperatorsInput {
  reference_no: FilterCountAdjustmentReference_noOperatorsInput
  document: FilterCountAdjustmentDocumentOperatorsInput
  note: FilterCountAdjustmentNoteOperatorsInput
  _id: FilterCountAdjustment_idOperatorsInput
  createdAt: FilterCountAdjustmentCreatedAtOperatorsInput
}

input FilterCountAdjustmentReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountAdjustmentDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountAdjustmentNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountAdjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountAdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type AdjustmentConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [AdjustmentEdge!]!
}

"""An edge in a connection."""
type AdjustmentEdge {
  """The item at the end of the edge"""
  node: Adjustment!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionAdjustmentEnum {
  _ID_DESC
  _ID_ASC
  REFERENCE_NO_DESC
  REFERENCE_NO_ASC
  DOCUMENT_DESC
  DOCUMENT_ASC
  NOTE_DESC
  NOTE_ASC
}

"""List of items with pagination."""
type AdjustmentPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Adjustment!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Attribute {
  name: String!
  values(limit: Int = 100, sort: SortFindByIdsValueInput): [Value!]!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Value {
  name: String!
  attribute: Attribute
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsValueInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

enum SortFindByIdsAttributeInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneAttributeOperatorsInput
  OR: [FilterFindOneAttributeInput!]
  AND: [FilterFindOneAttributeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneAttributeOperatorsInput {
  name: FilterFindOneAttributeNameOperatorsInput
  _id: FilterFindOneAttribute_idOperatorsInput
  createdAt: FilterFindOneAttributeCreatedAtOperatorsInput
}

input FilterFindOneAttributeNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneAttribute_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneAttributeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneAttributeInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyAttributeOperatorsInput
  OR: [FilterFindManyAttributeInput!]
  AND: [FilterFindManyAttributeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyAttributeOperatorsInput {
  name: FilterFindManyAttributeNameOperatorsInput
  _id: FilterFindManyAttribute_idOperatorsInput
  createdAt: FilterFindManyAttributeCreatedAtOperatorsInput
}

input FilterFindManyAttributeNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyAttribute_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyAttributeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyAttributeInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountAttributeOperatorsInput
  OR: [FilterCountAttributeInput!]
  AND: [FilterCountAttributeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountAttributeOperatorsInput {
  name: FilterCountAttributeNameOperatorsInput
  _id: FilterCountAttribute_idOperatorsInput
  createdAt: FilterCountAttributeCreatedAtOperatorsInput
}

input FilterCountAttributeNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountAttribute_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountAttributeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type AttributeConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [AttributeEdge!]!
}

"""An edge in a connection."""
type AttributeEdge {
  """The item at the end of the edge"""
  node: Attribute!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionAttributeEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
}

"""List of items with pagination."""
type AttributePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Attribute!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsBrandInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneBrandOperatorsInput
  OR: [FilterFindOneBrandInput!]
  AND: [FilterFindOneBrandInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneBrandOperatorsInput {
  name: FilterFindOneBrandNameOperatorsInput
  image: FilterFindOneBrandImageOperatorsInput
  _id: FilterFindOneBrand_idOperatorsInput
  createdAt: FilterFindOneBrandCreatedAtOperatorsInput
}

input FilterFindOneBrandNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneBrandImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneBrand_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneBrandCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneBrandInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyBrandOperatorsInput
  OR: [FilterFindManyBrandInput!]
  AND: [FilterFindManyBrandInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyBrandOperatorsInput {
  name: FilterFindManyBrandNameOperatorsInput
  image: FilterFindManyBrandImageOperatorsInput
  _id: FilterFindManyBrand_idOperatorsInput
  createdAt: FilterFindManyBrandCreatedAtOperatorsInput
}

input FilterFindManyBrandNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyBrandImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyBrand_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyBrandCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyBrandInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountBrandOperatorsInput
  OR: [FilterCountBrandInput!]
  AND: [FilterCountBrandInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountBrandOperatorsInput {
  name: FilterCountBrandNameOperatorsInput
  image: FilterCountBrandImageOperatorsInput
  _id: FilterCountBrand_idOperatorsInput
  createdAt: FilterCountBrandCreatedAtOperatorsInput
}

input FilterCountBrandNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountBrandImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountBrand_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountBrandCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type BrandConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [BrandEdge!]!
}

"""An edge in a connection."""
type BrandEdge {
  """The item at the end of the edge"""
  node: Brand!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionBrandEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
  IMAGE_DESC
  IMAGE_ASC
}

"""List of items with pagination."""
type BrandPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Brand!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsCategoryInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneCategoryOperatorsInput
  OR: [FilterFindOneCategoryInput!]
  AND: [FilterFindOneCategoryInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneCategoryOperatorsInput {
  name: FilterFindOneCategoryNameOperatorsInput
  image: FilterFindOneCategoryImageOperatorsInput
  _id: FilterFindOneCategory_idOperatorsInput
  createdAt: FilterFindOneCategoryCreatedAtOperatorsInput
}

input FilterFindOneCategoryNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneCategoryImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneCategory_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneCategoryCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneCategoryInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyCategoryOperatorsInput
  OR: [FilterFindManyCategoryInput!]
  AND: [FilterFindManyCategoryInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyCategoryOperatorsInput {
  name: FilterFindManyCategoryNameOperatorsInput
  image: FilterFindManyCategoryImageOperatorsInput
  _id: FilterFindManyCategory_idOperatorsInput
  createdAt: FilterFindManyCategoryCreatedAtOperatorsInput
}

input FilterFindManyCategoryNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyCategoryImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyCategory_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyCategoryCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyCategoryInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountCategoryOperatorsInput
  OR: [FilterCountCategoryInput!]
  AND: [FilterCountCategoryInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountCategoryOperatorsInput {
  name: FilterCountCategoryNameOperatorsInput
  image: FilterCountCategoryImageOperatorsInput
  _id: FilterCountCategory_idOperatorsInput
  createdAt: FilterCountCategoryCreatedAtOperatorsInput
}

input FilterCountCategoryNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountCategoryImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountCategory_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountCategoryCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type CategoryConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [CategoryEdge!]!
}

"""An edge in a connection."""
type CategoryEdge {
  """The item at the end of the edge"""
  node: Category!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionCategoryEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
  IMAGE_DESC
  IMAGE_ASC
}

"""List of items with pagination."""
type CategoryPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Category!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Coupon {
  code: String!
  coupon_type: String!
  amount: Float!
  min_amount: Float!
  user: User
  qty: Float!
  used: Boolean!
  expired_date: Date!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type User {
  name: String!
  password: String!
  role: Role
  personnel: MongoID!
  personnelModel: EnumUserPersonnelModel!
  warehouses(limit: Int = 100, sort: SortFindByIdsWarehouseInput): [Warehouse!]!
  is_active: Boolean!
  is_deleted: Boolean
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
  Personnel: User
}

type Role {
  name: String!
  description: String!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum EnumUserPersonnelModel {
  Employee
  Customer
  Supplier
}

enum SortFindByIdsWarehouseInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  PHONE_ASC
  PHONE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

enum SortFindByIdsCouponInput {
  _ID_ASC
  _ID_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneCouponOperatorsInput
  OR: [FilterFindOneCouponInput!]
  AND: [FilterFindOneCouponInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneCouponOperatorsInput {
  code: FilterFindOneCouponCodeOperatorsInput
  _id: FilterFindOneCoupon_idOperatorsInput
  createdAt: FilterFindOneCouponCreatedAtOperatorsInput
}

input FilterFindOneCouponCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneCoupon_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneCouponCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneCouponInput {
  _ID_ASC
  _ID_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyCouponOperatorsInput
  OR: [FilterFindManyCouponInput!]
  AND: [FilterFindManyCouponInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyCouponOperatorsInput {
  code: FilterFindManyCouponCodeOperatorsInput
  _id: FilterFindManyCoupon_idOperatorsInput
  createdAt: FilterFindManyCouponCreatedAtOperatorsInput
}

input FilterFindManyCouponCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyCoupon_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyCouponCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyCouponInput {
  _ID_ASC
  _ID_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountCouponOperatorsInput
  OR: [FilterCountCouponInput!]
  AND: [FilterCountCouponInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountCouponOperatorsInput {
  code: FilterCountCouponCodeOperatorsInput
  _id: FilterCountCoupon_idOperatorsInput
  createdAt: FilterCountCouponCreatedAtOperatorsInput
}

input FilterCountCouponCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountCoupon_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountCouponCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type CouponConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [CouponEdge!]!
}

"""An edge in a connection."""
type CouponEdge {
  """The item at the end of the edge"""
  node: Coupon!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionCouponEnum {
  _ID_DESC
  _ID_ASC
  CODE_DESC
  CODE_ASC
}

"""List of items with pagination."""
type CouponPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Coupon!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Customer {
  customer_group: Customer_Group
  company_name: String!
  name: String!
  image: String!
  email: String!
  phone_number: Float!
  gender: String!
  user: User
  address: String!
  city: String!
  country: String!
  tax_no: String
  deposit: Float!
  expense: Float!
  is_active: Boolean!
  is_deleted: Boolean
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Customer_Group {
  name: String!
  percentage: Float!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsCustomerInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  TAX_NO_ASC
  TAX_NO_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneCustomerOperatorsInput
  OR: [FilterFindOneCustomerInput!]
  AND: [FilterFindOneCustomerInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneCustomerOperatorsInput {
  email: FilterFindOneCustomerEmailOperatorsInput
  phone_number: FilterFindOneCustomerPhone_numberOperatorsInput
  tax_no: FilterFindOneCustomerTax_noOperatorsInput
  _id: FilterFindOneCustomer_idOperatorsInput
  createdAt: FilterFindOneCustomerCreatedAtOperatorsInput
}

input FilterFindOneCustomerEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneCustomerPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindOneCustomerTax_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneCustomer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneCustomerCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneCustomerInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  TAX_NO_ASC
  TAX_NO_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyCustomerOperatorsInput
  OR: [FilterFindManyCustomerInput!]
  AND: [FilterFindManyCustomerInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyCustomerOperatorsInput {
  email: FilterFindManyCustomerEmailOperatorsInput
  phone_number: FilterFindManyCustomerPhone_numberOperatorsInput
  tax_no: FilterFindManyCustomerTax_noOperatorsInput
  _id: FilterFindManyCustomer_idOperatorsInput
  createdAt: FilterFindManyCustomerCreatedAtOperatorsInput
}

input FilterFindManyCustomerEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyCustomerPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindManyCustomerTax_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyCustomer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyCustomerCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyCustomerInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  TAX_NO_ASC
  TAX_NO_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountCustomerOperatorsInput
  OR: [FilterCountCustomerInput!]
  AND: [FilterCountCustomerInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountCustomerOperatorsInput {
  email: FilterCountCustomerEmailOperatorsInput
  phone_number: FilterCountCustomerPhone_numberOperatorsInput
  tax_no: FilterCountCustomerTax_noOperatorsInput
  _id: FilterCountCustomer_idOperatorsInput
  createdAt: FilterCountCustomerCreatedAtOperatorsInput
}

input FilterCountCustomerEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountCustomerPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterCountCustomerTax_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountCustomer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountCustomerCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type CustomerConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [CustomerEdge!]!
}

"""An edge in a connection."""
type CustomerEdge {
  """The item at the end of the edge"""
  node: Customer!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionCustomerEnum {
  _ID_DESC
  _ID_ASC
  EMAIL_DESC
  EMAIL_ASC
  PHONE_NUMBER_DESC
  PHONE_NUMBER_ASC
  TAX_NO_DESC
  TAX_NO_ASC
}

"""List of items with pagination."""
type CustomerPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Customer!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsCustomer_GroupInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneCustomer_GroupOperatorsInput
  OR: [FilterFindOneCustomer_GroupInput!]
  AND: [FilterFindOneCustomer_GroupInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneCustomer_GroupOperatorsInput {
  name: FilterFindOneCustomer_GroupNameOperatorsInput
  _id: FilterFindOneCustomer_Group_idOperatorsInput
  createdAt: FilterFindOneCustomer_GroupCreatedAtOperatorsInput
}

input FilterFindOneCustomer_GroupNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneCustomer_Group_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneCustomer_GroupCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneCustomer_GroupInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyCustomer_GroupOperatorsInput
  OR: [FilterFindManyCustomer_GroupInput!]
  AND: [FilterFindManyCustomer_GroupInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyCustomer_GroupOperatorsInput {
  name: FilterFindManyCustomer_GroupNameOperatorsInput
  _id: FilterFindManyCustomer_Group_idOperatorsInput
  createdAt: FilterFindManyCustomer_GroupCreatedAtOperatorsInput
}

input FilterFindManyCustomer_GroupNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyCustomer_Group_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyCustomer_GroupCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyCustomer_GroupInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountCustomer_GroupOperatorsInput
  OR: [FilterCountCustomer_GroupInput!]
  AND: [FilterCountCustomer_GroupInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountCustomer_GroupOperatorsInput {
  name: FilterCountCustomer_GroupNameOperatorsInput
  _id: FilterCountCustomer_Group_idOperatorsInput
  createdAt: FilterCountCustomer_GroupCreatedAtOperatorsInput
}

input FilterCountCustomer_GroupNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountCustomer_Group_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountCustomer_GroupCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Customer_GroupConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Customer_GroupEdge!]!
}

"""An edge in a connection."""
type Customer_GroupEdge {
  """The item at the end of the edge"""
  node: Customer_Group!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionCustomer_GroupEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
}

"""List of items with pagination."""
type Customer_GroupPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Customer_Group!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Department {
  name: String!
  is_active: Boolean!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsDepartmentInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneDepartmentInput {
  name: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneDepartmentOperatorsInput
  OR: [FilterFindOneDepartmentInput!]
  AND: [FilterFindOneDepartmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneDepartmentOperatorsInput {
  name: FilterFindOneDepartmentNameOperatorsInput
  _id: FilterFindOneDepartment_idOperatorsInput
  createdAt: FilterFindOneDepartmentCreatedAtOperatorsInput
}

input FilterFindOneDepartmentNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneDepartment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneDepartmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneDepartmentInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyDepartmentInput {
  name: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyDepartmentOperatorsInput
  OR: [FilterFindManyDepartmentInput!]
  AND: [FilterFindManyDepartmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyDepartmentOperatorsInput {
  name: FilterFindManyDepartmentNameOperatorsInput
  _id: FilterFindManyDepartment_idOperatorsInput
  createdAt: FilterFindManyDepartmentCreatedAtOperatorsInput
}

input FilterFindManyDepartmentNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyDepartment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyDepartmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyDepartmentInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountDepartmentInput {
  name: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountDepartmentOperatorsInput
  OR: [FilterCountDepartmentInput!]
  AND: [FilterCountDepartmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountDepartmentOperatorsInput {
  name: FilterCountDepartmentNameOperatorsInput
  _id: FilterCountDepartment_idOperatorsInput
  createdAt: FilterCountDepartmentCreatedAtOperatorsInput
}

input FilterCountDepartmentNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountDepartment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountDepartmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type DepartmentConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [DepartmentEdge!]!
}

"""An edge in a connection."""
type DepartmentEdge {
  """The item at the end of the edge"""
  node: Department!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionDepartmentEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
}

"""List of items with pagination."""
type DepartmentPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Department!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Employee {
  name: String!
  image: String!
  email: String!
  phone_number: Float!
  gender: String!
  user: User
  department: Department
  payrolls(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsPayrollInput): [Payroll!]!
  address: String!
  city: String!
  country: String!
  is_active: Boolean!
  is_deleted: Boolean
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Payroll {
  reference_no: String!
  amount: Float!
  user: MongoID!
  employee: MongoID!
  account: MongoID!
  paying_method: String!
  note: String
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsPayrollInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

enum SortFindByIdsEmployeeInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneEmployeeOperatorsInput
  OR: [FilterFindOneEmployeeInput!]
  AND: [FilterFindOneEmployeeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneEmployeeOperatorsInput {
  email: FilterFindOneEmployeeEmailOperatorsInput
  phone_number: FilterFindOneEmployeePhone_numberOperatorsInput
  _id: FilterFindOneEmployee_idOperatorsInput
  createdAt: FilterFindOneEmployeeCreatedAtOperatorsInput
}

input FilterFindOneEmployeeEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneEmployeePhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindOneEmployee_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneEmployeeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneEmployeeInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyEmployeeOperatorsInput
  OR: [FilterFindManyEmployeeInput!]
  AND: [FilterFindManyEmployeeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyEmployeeOperatorsInput {
  email: FilterFindManyEmployeeEmailOperatorsInput
  phone_number: FilterFindManyEmployeePhone_numberOperatorsInput
  _id: FilterFindManyEmployee_idOperatorsInput
  createdAt: FilterFindManyEmployeeCreatedAtOperatorsInput
}

input FilterFindManyEmployeeEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyEmployeePhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindManyEmployee_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyEmployeeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyEmployeeInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountEmployeeOperatorsInput
  OR: [FilterCountEmployeeInput!]
  AND: [FilterCountEmployeeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountEmployeeOperatorsInput {
  email: FilterCountEmployeeEmailOperatorsInput
  phone_number: FilterCountEmployeePhone_numberOperatorsInput
  _id: FilterCountEmployee_idOperatorsInput
  createdAt: FilterCountEmployeeCreatedAtOperatorsInput
}

input FilterCountEmployeeEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountEmployeePhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterCountEmployee_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountEmployeeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type EmployeeConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [EmployeeEdge!]!
}

"""An edge in a connection."""
type EmployeeEdge {
  """The item at the end of the edge"""
  node: Employee!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionEmployeeEnum {
  _ID_DESC
  _ID_ASC
  EMAIL_DESC
  EMAIL_ASC
  PHONE_NUMBER_DESC
  PHONE_NUMBER_ASC
}

"""List of items with pagination."""
type EmployeePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Employee!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

""""""
input FilterFindOneProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProduct_AdjustmentOperatorsInput
  OR: [FilterFindOneProduct_AdjustmentInput!]
  AND: [FilterFindOneProduct_AdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProduct_AdjustmentOperatorsInput {
  adjustment: FilterFindOneProduct_AdjustmentAdjustmentOperatorsInput
  _id: FilterFindOneProduct_Adjustment_idOperatorsInput
  createdAt: FilterFindOneProduct_AdjustmentCreatedAtOperatorsInput
}

input FilterFindOneProduct_AdjustmentAdjustmentOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_Adjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_AdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProduct_AdjustmentInput {
  _ID_ASC
  _ID_DESC
  ADJUSTMENT_ASC
  ADJUSTMENT_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProduct_AdjustmentOperatorsInput
  OR: [FilterFindManyProduct_AdjustmentInput!]
  AND: [FilterFindManyProduct_AdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProduct_AdjustmentOperatorsInput {
  adjustment: FilterFindManyProduct_AdjustmentAdjustmentOperatorsInput
  _id: FilterFindManyProduct_Adjustment_idOperatorsInput
  createdAt: FilterFindManyProduct_AdjustmentCreatedAtOperatorsInput
}

input FilterFindManyProduct_AdjustmentAdjustmentOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_Adjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_AdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProduct_AdjustmentInput {
  _ID_ASC
  _ID_DESC
  ADJUSTMENT_ASC
  ADJUSTMENT_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProduct_AdjustmentOperatorsInput
  OR: [FilterCountProduct_AdjustmentInput!]
  AND: [FilterCountProduct_AdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProduct_AdjustmentOperatorsInput {
  adjustment: FilterCountProduct_AdjustmentAdjustmentOperatorsInput
  _id: FilterCountProduct_Adjustment_idOperatorsInput
  createdAt: FilterCountProduct_AdjustmentCreatedAtOperatorsInput
}

input FilterCountProduct_AdjustmentAdjustmentOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_Adjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_AdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Product_AdjustmentConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Product_AdjustmentEdge!]!
}

"""An edge in a connection."""
type Product_AdjustmentEdge {
  """The item at the end of the edge"""
  node: Product_Adjustment!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProduct_AdjustmentEnum {
  _ID_DESC
  _ID_ASC
  ADJUSTMENT_DESC
  ADJUSTMENT_ASC
}

"""List of items with pagination."""
type Product_AdjustmentPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product_Adjustment!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Product_Purchase {
  purchase: Purchase
  product_variant: Product_Variant
  unit: Unit
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_cost: Float!
  total: Float!
  status: EnumProduct_PurchaseStatus!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Purchase {
  reference_no: String!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_cost: Float!
  order_tax_rate: Float!
  order_tax: Float!
  order_discount: Float!
  shipping_cost: Float!
  grandtotal: Float!
  paid_amount: Float!
  user: User
  warehouse: Warehouse
  supplier: Supplier
  product_purchases(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_PurchaseInput): [Product_Purchase!]!
  product_purchase_returns(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_Purchase_ReturnInput): [Product_Purchase_Return!]!
  status: EnumPurchaseStatus!
  payment_status: EnumPurchasePayment_status!
  document: String
  note: String
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsProduct_PurchaseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type Product_Purchase_Return {
  return: MongoID!
  product_variant: MongoID!
  unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_cost: Float!
  total: Float!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsProduct_Purchase_ReturnInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

enum EnumPurchaseStatus {
  Recieved
  Partial
  Pending
  Ordered
}

enum EnumPurchasePayment_status {
  Pending
  Due
  Partial
  Paid
}

enum EnumProduct_PurchaseStatus {
  Recieved
  Partial
  Pending
  Ordered
}

""""""
input FilterFindOneProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProduct_PurchaseOperatorsInput
  OR: [FilterFindOneProduct_PurchaseInput!]
  AND: [FilterFindOneProduct_PurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProduct_PurchaseOperatorsInput {
  _id: FilterFindOneProduct_Purchase_idOperatorsInput
  createdAt: FilterFindOneProduct_PurchaseCreatedAtOperatorsInput
}

input FilterFindOneProduct_Purchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_PurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProduct_PurchaseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProduct_PurchaseOperatorsInput
  OR: [FilterFindManyProduct_PurchaseInput!]
  AND: [FilterFindManyProduct_PurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProduct_PurchaseOperatorsInput {
  _id: FilterFindManyProduct_Purchase_idOperatorsInput
  createdAt: FilterFindManyProduct_PurchaseCreatedAtOperatorsInput
}

input FilterFindManyProduct_Purchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_PurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProduct_PurchaseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProduct_PurchaseOperatorsInput
  OR: [FilterCountProduct_PurchaseInput!]
  AND: [FilterCountProduct_PurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProduct_PurchaseOperatorsInput {
  _id: FilterCountProduct_Purchase_idOperatorsInput
  createdAt: FilterCountProduct_PurchaseCreatedAtOperatorsInput
}

input FilterCountProduct_Purchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_PurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Product_PurchaseConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Product_PurchaseEdge!]!
}

"""An edge in a connection."""
type Product_PurchaseEdge {
  """The item at the end of the edge"""
  node: Product_Purchase!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProduct_PurchaseEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type Product_PurchasePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product_Purchase!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Product_Quotation {
  quotation: Quotation
  product_variant: Product_Variant
  unit: Unit
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_price: Float!
  total: Float!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Quotation {
  reference_no: String!
  user: User
  biller: Employee
  warehouse: Warehouse
  supplier: Supplier
  customer: Customer
  product_quotations: [MongoID]!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_price: Float!
  order_tax_rate: Float!
  order_tax: Float!
  order_discount: Float!
  shipping_cost: Float!
  grandtotal: Float!
  paid_amount: Float!
  status: EnumQuotationStatus!
  document: String
  note: String
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
  product_qoutations(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_QuotationInput): [Product_Quotation!]!
}

enum EnumQuotationStatus {
  Sent
  Pending
}

enum SortFindByIdsProduct_QuotationInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProduct_QuotationOperatorsInput
  OR: [FilterFindOneProduct_QuotationInput!]
  AND: [FilterFindOneProduct_QuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProduct_QuotationOperatorsInput {
  _id: FilterFindOneProduct_Quotation_idOperatorsInput
  createdAt: FilterFindOneProduct_QuotationCreatedAtOperatorsInput
}

input FilterFindOneProduct_Quotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_QuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProduct_QuotationInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProduct_QuotationOperatorsInput
  OR: [FilterFindManyProduct_QuotationInput!]
  AND: [FilterFindManyProduct_QuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProduct_QuotationOperatorsInput {
  _id: FilterFindManyProduct_Quotation_idOperatorsInput
  createdAt: FilterFindManyProduct_QuotationCreatedAtOperatorsInput
}

input FilterFindManyProduct_Quotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_QuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProduct_QuotationInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProduct_QuotationOperatorsInput
  OR: [FilterCountProduct_QuotationInput!]
  AND: [FilterCountProduct_QuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProduct_QuotationOperatorsInput {
  _id: FilterCountProduct_Quotation_idOperatorsInput
  createdAt: FilterCountProduct_QuotationCreatedAtOperatorsInput
}

input FilterCountProduct_Quotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_QuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Product_QuotationConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Product_QuotationEdge!]!
}

"""An edge in a connection."""
type Product_QuotationEdge {
  """The item at the end of the edge"""
  node: Product_Quotation!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProduct_QuotationEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type Product_QuotationPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product_Quotation!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Product_Return {
  return: Return
  product_variant: Product_Variant
  unit: Unit
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_price: Float!
  total: Float!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Return {
  reference_no: String!
  user: User
  biller: Employee
  warehouse: Warehouse
  account: Account
  customer: Customer
  product_returns(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_ReturnInput): [Product_Return!]!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_price: Float!
  order_tax_rate: Float!
  order_tax: Float!
  grandtotal: Float!
  document: String
  return_note: String
  staff_note: String
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsProduct_ReturnInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProduct_ReturnOperatorsInput
  OR: [FilterFindOneProduct_ReturnInput!]
  AND: [FilterFindOneProduct_ReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProduct_ReturnOperatorsInput {
  _id: FilterFindOneProduct_Return_idOperatorsInput
  createdAt: FilterFindOneProduct_ReturnCreatedAtOperatorsInput
}

input FilterFindOneProduct_Return_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_ReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProduct_ReturnInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProduct_ReturnOperatorsInput
  OR: [FilterFindManyProduct_ReturnInput!]
  AND: [FilterFindManyProduct_ReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProduct_ReturnOperatorsInput {
  _id: FilterFindManyProduct_Return_idOperatorsInput
  createdAt: FilterFindManyProduct_ReturnCreatedAtOperatorsInput
}

input FilterFindManyProduct_Return_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_ReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProduct_ReturnInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProduct_ReturnOperatorsInput
  OR: [FilterCountProduct_ReturnInput!]
  AND: [FilterCountProduct_ReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProduct_ReturnOperatorsInput {
  _id: FilterCountProduct_Return_idOperatorsInput
  createdAt: FilterCountProduct_ReturnCreatedAtOperatorsInput
}

input FilterCountProduct_Return_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_ReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Product_ReturnConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Product_ReturnEdge!]!
}

"""An edge in a connection."""
type Product_ReturnEdge {
  """The item at the end of the edge"""
  node: Product_Return!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProduct_ReturnEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type Product_ReturnPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product_Return!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Product_Sale {
  sale: Sale
  product_variant: Product_Variant
  unit: Unit
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_price: Float!
  total: Float!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

type Sale {
  reference_no: String!
  user: MongoID!
  biller: MongoID!
  warehouse: MongoID!
  coupon: MongoID!
  customer: MongoID!
  product_sales: [MongoID]!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_price: Float!
  order_tax_rate: Float!
  order_tax: Float!
  order_discount: Float!
  shipping_cost: Float!
  coupon_discount: Float!
  grandtotal: Float!
  paid_amount: Float!
  sale_status: EnumSaleSale_status!
  payment_status: EnumSalePayment_status!
  document: String
  sale_note: String
  staff_note: String
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum EnumSaleSale_status {
  Completed
  Pending
}

enum EnumSalePayment_status {
  Due
  Pending
  Partial
  Paid
}

enum SortFindByIdsProduct_SaleInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProduct_SaleOperatorsInput
  OR: [FilterFindOneProduct_SaleInput!]
  AND: [FilterFindOneProduct_SaleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProduct_SaleOperatorsInput {
  _id: FilterFindOneProduct_Sale_idOperatorsInput
  createdAt: FilterFindOneProduct_SaleCreatedAtOperatorsInput
}

input FilterFindOneProduct_Sale_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_SaleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProduct_SaleInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProduct_SaleOperatorsInput
  OR: [FilterFindManyProduct_SaleInput!]
  AND: [FilterFindManyProduct_SaleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProduct_SaleOperatorsInput {
  _id: FilterFindManyProduct_Sale_idOperatorsInput
  createdAt: FilterFindManyProduct_SaleCreatedAtOperatorsInput
}

input FilterFindManyProduct_Sale_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_SaleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProduct_SaleInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProduct_SaleOperatorsInput
  OR: [FilterCountProduct_SaleInput!]
  AND: [FilterCountProduct_SaleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProduct_SaleOperatorsInput {
  _id: FilterCountProduct_Sale_idOperatorsInput
  createdAt: FilterCountProduct_SaleCreatedAtOperatorsInput
}

input FilterCountProduct_Sale_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_SaleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Product_SaleConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Product_SaleEdge!]!
}

"""An edge in a connection."""
type Product_SaleEdge {
  """The item at the end of the edge"""
  node: Product_Sale!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProduct_SaleEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type Product_SalePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product_Sale!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

""""""
input FilterFindOneProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProduct_SupplierOperatorsInput
  OR: [FilterFindOneProduct_SupplierInput!]
  AND: [FilterFindOneProduct_SupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProduct_SupplierOperatorsInput {
  itemCode: FilterFindOneProduct_SupplierItemCodeOperatorsInput
  _id: FilterFindOneProduct_Supplier_idOperatorsInput
  createdAt: FilterFindOneProduct_SupplierCreatedAtOperatorsInput
}

input FilterFindOneProduct_SupplierItemCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneProduct_Supplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_SupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProduct_SupplierInput {
  _ID_ASC
  _ID_DESC
  ITEMCODE_ASC
  ITEMCODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProduct_SupplierOperatorsInput
  OR: [FilterFindManyProduct_SupplierInput!]
  AND: [FilterFindManyProduct_SupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProduct_SupplierOperatorsInput {
  itemCode: FilterFindManyProduct_SupplierItemCodeOperatorsInput
  _id: FilterFindManyProduct_Supplier_idOperatorsInput
  createdAt: FilterFindManyProduct_SupplierCreatedAtOperatorsInput
}

input FilterFindManyProduct_SupplierItemCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyProduct_Supplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_SupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProduct_SupplierInput {
  _ID_ASC
  _ID_DESC
  ITEMCODE_ASC
  ITEMCODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProduct_SupplierOperatorsInput
  OR: [FilterCountProduct_SupplierInput!]
  AND: [FilterCountProduct_SupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProduct_SupplierOperatorsInput {
  itemCode: FilterCountProduct_SupplierItemCodeOperatorsInput
  _id: FilterCountProduct_Supplier_idOperatorsInput
  createdAt: FilterCountProduct_SupplierCreatedAtOperatorsInput
}

input FilterCountProduct_SupplierItemCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountProduct_Supplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_SupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Product_SupplierConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Product_SupplierEdge!]!
}

"""An edge in a connection."""
type Product_SupplierEdge {
  """The item at the end of the edge"""
  node: Product_Supplier!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProduct_SupplierEnum {
  _ID_DESC
  _ID_ASC
  ITEMCODE_DESC
  ITEMCODE_ASC
}

"""List of items with pagination."""
type Product_SupplierPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product_Supplier!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Product_Transfer {
  transfer: MongoID!
  product_variant: Product_Variant
  purchase_unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  net_unit_cost: Float!
  total: Float!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
  purchase: Transfer
  unit: Unit
}

type Transfer {
  reference_no: String!
  item: Float!
  total_qty: Float!
  total_tax: Float!
  total_cost: Float!
  shipping_cost: Float!
  grand_total: Float!
  paid_amount: Float!
  user: User
  from_warehouse: Warehouse
  to_warehouse: Warehouse
  product_transfers(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsProduct_TransferInput): [Product_Transfer!]!
  status: EnumTransferStatus!
  document: String
  note: String
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsProduct_TransferInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

enum EnumTransferStatus {
  Completed
  Pending
  Sent
}

""""""
input FilterFindOneProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProduct_TransferOperatorsInput
  OR: [FilterFindOneProduct_TransferInput!]
  AND: [FilterFindOneProduct_TransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProduct_TransferOperatorsInput {
  _id: FilterFindOneProduct_Transfer_idOperatorsInput
  createdAt: FilterFindOneProduct_TransferCreatedAtOperatorsInput
}

input FilterFindOneProduct_Transfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_TransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProduct_TransferInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProduct_TransferOperatorsInput
  OR: [FilterFindManyProduct_TransferInput!]
  AND: [FilterFindManyProduct_TransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProduct_TransferOperatorsInput {
  _id: FilterFindManyProduct_Transfer_idOperatorsInput
  createdAt: FilterFindManyProduct_TransferCreatedAtOperatorsInput
}

input FilterFindManyProduct_Transfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_TransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProduct_TransferInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProduct_TransferOperatorsInput
  OR: [FilterCountProduct_TransferInput!]
  AND: [FilterCountProduct_TransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProduct_TransferOperatorsInput {
  _id: FilterCountProduct_Transfer_idOperatorsInput
  createdAt: FilterCountProduct_TransferCreatedAtOperatorsInput
}

input FilterCountProduct_Transfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_TransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Product_TransferConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Product_TransferEdge!]!
}

"""An edge in a connection."""
type Product_TransferEdge {
  """The item at the end of the edge"""
  node: Product_Transfer!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProduct_TransferEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type Product_TransferPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product_Transfer!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

""""""
input FilterFindOneProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProduct_VariantOperatorsInput
  OR: [FilterFindOneProduct_VariantInput!]
  AND: [FilterFindOneProduct_VariantInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProduct_VariantOperatorsInput {
  variant: FilterFindOneProduct_VariantVariantOperatorsInput
  item_code: FilterFindOneProduct_VariantItem_codeOperatorsInput
  _id: FilterFindOneProduct_Variant_idOperatorsInput
  createdAt: FilterFindOneProduct_VariantCreatedAtOperatorsInput
}

input FilterFindOneProduct_VariantVariantOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_VariantItem_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneProduct_Variant_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_VariantCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProduct_VariantInput {
  _ID_ASC
  _ID_DESC
  VARIANT_ASC
  VARIANT_DESC
  ITEM_CODE_ASC
  ITEM_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProduct_VariantOperatorsInput
  OR: [FilterFindManyProduct_VariantInput!]
  AND: [FilterFindManyProduct_VariantInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProduct_VariantOperatorsInput {
  variant: FilterFindManyProduct_VariantVariantOperatorsInput
  item_code: FilterFindManyProduct_VariantItem_codeOperatorsInput
  _id: FilterFindManyProduct_Variant_idOperatorsInput
  createdAt: FilterFindManyProduct_VariantCreatedAtOperatorsInput
}

input FilterFindManyProduct_VariantVariantOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_VariantItem_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyProduct_Variant_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_VariantCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProduct_VariantInput {
  _ID_ASC
  _ID_DESC
  VARIANT_ASC
  VARIANT_DESC
  ITEM_CODE_ASC
  ITEM_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProduct_VariantOperatorsInput
  OR: [FilterCountProduct_VariantInput!]
  AND: [FilterCountProduct_VariantInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProduct_VariantOperatorsInput {
  variant: FilterCountProduct_VariantVariantOperatorsInput
  item_code: FilterCountProduct_VariantItem_codeOperatorsInput
  _id: FilterCountProduct_Variant_idOperatorsInput
  createdAt: FilterCountProduct_VariantCreatedAtOperatorsInput
}

input FilterCountProduct_VariantVariantOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_VariantItem_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountProduct_Variant_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_VariantCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Product_VariantConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Product_VariantEdge!]!
}

"""An edge in a connection."""
type Product_VariantEdge {
  """The item at the end of the edge"""
  node: Product_Variant!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProduct_VariantEnum {
  _ID_DESC
  _ID_ASC
  VARIANT_DESC
  VARIANT_ASC
  ITEM_CODE_DESC
  ITEM_CODE_ASC
}

"""List of items with pagination."""
type Product_VariantPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product_Variant!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Product_Warehouse {
  product_variant: Product_Variant
  warehouse: Warehouse
  qty: Float!
  _id: MongoID!
  updatedAt: Date
  createdAt: Date
}

enum SortFindByIdsProduct_WarehouseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProduct_WarehouseOperatorsInput
  OR: [FilterFindOneProduct_WarehouseInput!]
  AND: [FilterFindOneProduct_WarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProduct_WarehouseOperatorsInput {
  _id: FilterFindOneProduct_Warehouse_idOperatorsInput
  createdAt: FilterFindOneProduct_WarehouseCreatedAtOperatorsInput
}

input FilterFindOneProduct_Warehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProduct_WarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProduct_WarehouseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProduct_WarehouseOperatorsInput
  OR: [FilterFindManyProduct_WarehouseInput!]
  AND: [FilterFindManyProduct_WarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProduct_WarehouseOperatorsInput {
  _id: FilterFindManyProduct_Warehouse_idOperatorsInput
  createdAt: FilterFindManyProduct_WarehouseCreatedAtOperatorsInput
}

input FilterFindManyProduct_Warehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProduct_WarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProduct_WarehouseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProduct_WarehouseOperatorsInput
  OR: [FilterCountProduct_WarehouseInput!]
  AND: [FilterCountProduct_WarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProduct_WarehouseOperatorsInput {
  _id: FilterCountProduct_Warehouse_idOperatorsInput
  createdAt: FilterCountProduct_WarehouseCreatedAtOperatorsInput
}

input FilterCountProduct_Warehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProduct_WarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type Product_WarehouseConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [Product_WarehouseEdge!]!
}

"""An edge in a connection."""
type Product_WarehouseEdge {
  """The item at the end of the edge"""
  node: Product_Warehouse!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProduct_WarehouseEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type Product_WarehousePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product_Warehouse!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

""""""
input FilterFindOneProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneProductOperatorsInput
  OR: [FilterFindOneProductInput!]
  AND: [FilterFindOneProductInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneProductOperatorsInput {
  name: FilterFindOneProductNameOperatorsInput
  code: FilterFindOneProductCodeOperatorsInput
  _id: FilterFindOneProduct_idOperatorsInput
  createdAt: FilterFindOneProductCreatedAtOperatorsInput
}

input FilterFindOneProductNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneProductCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneProduct_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneProductCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneProductInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyProductOperatorsInput
  OR: [FilterFindManyProductInput!]
  AND: [FilterFindManyProductInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyProductOperatorsInput {
  name: FilterFindManyProductNameOperatorsInput
  code: FilterFindManyProductCodeOperatorsInput
  _id: FilterFindManyProduct_idOperatorsInput
  createdAt: FilterFindManyProductCreatedAtOperatorsInput
}

input FilterFindManyProductNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyProductCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyProduct_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyProductCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyProductInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountProductOperatorsInput
  OR: [FilterCountProductInput!]
  AND: [FilterCountProductInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountProductOperatorsInput {
  name: FilterCountProductNameOperatorsInput
  code: FilterCountProductCodeOperatorsInput
  _id: FilterCountProduct_idOperatorsInput
  createdAt: FilterCountProductCreatedAtOperatorsInput
}

input FilterCountProductNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountProductCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountProduct_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountProductCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type ProductConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ProductEdge!]!
}

"""An edge in a connection."""
type ProductEdge {
  """The item at the end of the edge"""
  node: Product!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionProductEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
  CODE_DESC
  CODE_ASC
}

"""List of items with pagination."""
type ProductPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Product!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsPurchaseInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOnePurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOnePurchaseOperatorsInput
  OR: [FilterFindOnePurchaseInput!]
  AND: [FilterFindOnePurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOnePurchaseOperatorsInput {
  reference_no: FilterFindOnePurchaseReference_noOperatorsInput
  document: FilterFindOnePurchaseDocumentOperatorsInput
  note: FilterFindOnePurchaseNoteOperatorsInput
  _id: FilterFindOnePurchase_idOperatorsInput
  createdAt: FilterFindOnePurchaseCreatedAtOperatorsInput
}

input FilterFindOnePurchaseReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOnePurchaseDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOnePurchaseNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOnePurchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOnePurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOnePurchaseInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyPurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyPurchaseOperatorsInput
  OR: [FilterFindManyPurchaseInput!]
  AND: [FilterFindManyPurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyPurchaseOperatorsInput {
  reference_no: FilterFindManyPurchaseReference_noOperatorsInput
  document: FilterFindManyPurchaseDocumentOperatorsInput
  note: FilterFindManyPurchaseNoteOperatorsInput
  _id: FilterFindManyPurchase_idOperatorsInput
  createdAt: FilterFindManyPurchaseCreatedAtOperatorsInput
}

input FilterFindManyPurchaseReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyPurchaseDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyPurchaseNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyPurchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyPurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyPurchaseInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountPurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountPurchaseOperatorsInput
  OR: [FilterCountPurchaseInput!]
  AND: [FilterCountPurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountPurchaseOperatorsInput {
  reference_no: FilterCountPurchaseReference_noOperatorsInput
  document: FilterCountPurchaseDocumentOperatorsInput
  note: FilterCountPurchaseNoteOperatorsInput
  _id: FilterCountPurchase_idOperatorsInput
  createdAt: FilterCountPurchaseCreatedAtOperatorsInput
}

input FilterCountPurchaseReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountPurchaseDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountPurchaseNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountPurchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountPurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type PurchaseConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [PurchaseEdge!]!
}

"""An edge in a connection."""
type PurchaseEdge {
  """The item at the end of the edge"""
  node: Purchase!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionPurchaseEnum {
  _ID_DESC
  _ID_ASC
  REFERENCE_NO_DESC
  REFERENCE_NO_ASC
  DOCUMENT_DESC
  DOCUMENT_ASC
  NOTE_DESC
  NOTE_ASC
}

"""List of items with pagination."""
type PurchasePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Purchase!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsQuotationInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneQuotationOperatorsInput
  OR: [FilterFindOneQuotationInput!]
  AND: [FilterFindOneQuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneQuotationOperatorsInput {
  reference_no: FilterFindOneQuotationReference_noOperatorsInput
  document: FilterFindOneQuotationDocumentOperatorsInput
  note: FilterFindOneQuotationNoteOperatorsInput
  _id: FilterFindOneQuotation_idOperatorsInput
  createdAt: FilterFindOneQuotationCreatedAtOperatorsInput
}

input FilterFindOneQuotationReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneQuotationDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneQuotationNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneQuotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneQuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneQuotationInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyQuotationOperatorsInput
  OR: [FilterFindManyQuotationInput!]
  AND: [FilterFindManyQuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyQuotationOperatorsInput {
  reference_no: FilterFindManyQuotationReference_noOperatorsInput
  document: FilterFindManyQuotationDocumentOperatorsInput
  note: FilterFindManyQuotationNoteOperatorsInput
  _id: FilterFindManyQuotation_idOperatorsInput
  createdAt: FilterFindManyQuotationCreatedAtOperatorsInput
}

input FilterFindManyQuotationReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyQuotationDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyQuotationNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyQuotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyQuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyQuotationInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountQuotationOperatorsInput
  OR: [FilterCountQuotationInput!]
  AND: [FilterCountQuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountQuotationOperatorsInput {
  reference_no: FilterCountQuotationReference_noOperatorsInput
  document: FilterCountQuotationDocumentOperatorsInput
  note: FilterCountQuotationNoteOperatorsInput
  _id: FilterCountQuotation_idOperatorsInput
  createdAt: FilterCountQuotationCreatedAtOperatorsInput
}

input FilterCountQuotationReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountQuotationDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountQuotationNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountQuotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountQuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type QuotationConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [QuotationEdge!]!
}

"""An edge in a connection."""
type QuotationEdge {
  """The item at the end of the edge"""
  node: Quotation!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionQuotationEnum {
  _ID_DESC
  _ID_ASC
  REFERENCE_NO_DESC
  REFERENCE_NO_ASC
  DOCUMENT_DESC
  DOCUMENT_ASC
  NOTE_DESC
  NOTE_ASC
}

"""List of items with pagination."""
type QuotationPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Quotation!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsReturnInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  RETURN_NOTE_ASC
  RETURN_NOTE_DESC
  STAFF_NOTE_ASC
  STAFF_NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneReturnOperatorsInput
  OR: [FilterFindOneReturnInput!]
  AND: [FilterFindOneReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneReturnOperatorsInput {
  reference_no: FilterFindOneReturnReference_noOperatorsInput
  document: FilterFindOneReturnDocumentOperatorsInput
  return_note: FilterFindOneReturnReturn_noteOperatorsInput
  staff_note: FilterFindOneReturnStaff_noteOperatorsInput
  _id: FilterFindOneReturn_idOperatorsInput
  createdAt: FilterFindOneReturnCreatedAtOperatorsInput
}

input FilterFindOneReturnReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneReturnDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneReturnReturn_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneReturnStaff_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneReturn_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneReturnInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  RETURN_NOTE_ASC
  RETURN_NOTE_DESC
  STAFF_NOTE_ASC
  STAFF_NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyReturnOperatorsInput
  OR: [FilterFindManyReturnInput!]
  AND: [FilterFindManyReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyReturnOperatorsInput {
  reference_no: FilterFindManyReturnReference_noOperatorsInput
  document: FilterFindManyReturnDocumentOperatorsInput
  return_note: FilterFindManyReturnReturn_noteOperatorsInput
  staff_note: FilterFindManyReturnStaff_noteOperatorsInput
  _id: FilterFindManyReturn_idOperatorsInput
  createdAt: FilterFindManyReturnCreatedAtOperatorsInput
}

input FilterFindManyReturnReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyReturnDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyReturnReturn_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyReturnStaff_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyReturn_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyReturnInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  RETURN_NOTE_ASC
  RETURN_NOTE_DESC
  STAFF_NOTE_ASC
  STAFF_NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountReturnOperatorsInput
  OR: [FilterCountReturnInput!]
  AND: [FilterCountReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountReturnOperatorsInput {
  reference_no: FilterCountReturnReference_noOperatorsInput
  document: FilterCountReturnDocumentOperatorsInput
  return_note: FilterCountReturnReturn_noteOperatorsInput
  staff_note: FilterCountReturnStaff_noteOperatorsInput
  _id: FilterCountReturn_idOperatorsInput
  createdAt: FilterCountReturnCreatedAtOperatorsInput
}

input FilterCountReturnReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountReturnDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountReturnReturn_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountReturnStaff_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountReturn_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type ReturnConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ReturnEdge!]!
}

"""An edge in a connection."""
type ReturnEdge {
  """The item at the end of the edge"""
  node: Return!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionReturnEnum {
  _ID_DESC
  _ID_ASC
  REFERENCE_NO_DESC
  REFERENCE_NO_ASC
  DOCUMENT_DESC
  DOCUMENT_ASC
  RETURN_NOTE_DESC
  RETURN_NOTE_ASC
  STAFF_NOTE_DESC
  STAFF_NOTE_ASC
}

"""List of items with pagination."""
type ReturnPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Return!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsRoleInput {
  _ID_ASC
  _ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneRoleInput {
  name: String
  description: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneRoleOperatorsInput
  OR: [FilterFindOneRoleInput!]
  AND: [FilterFindOneRoleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneRoleOperatorsInput {
  description: FilterFindOneRoleDescriptionOperatorsInput
  _id: FilterFindOneRole_idOperatorsInput
  createdAt: FilterFindOneRoleCreatedAtOperatorsInput
}

input FilterFindOneRoleDescriptionOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneRole_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneRoleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneRoleInput {
  _ID_ASC
  _ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyRoleInput {
  name: String
  description: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyRoleOperatorsInput
  OR: [FilterFindManyRoleInput!]
  AND: [FilterFindManyRoleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyRoleOperatorsInput {
  description: FilterFindManyRoleDescriptionOperatorsInput
  _id: FilterFindManyRole_idOperatorsInput
  createdAt: FilterFindManyRoleCreatedAtOperatorsInput
}

input FilterFindManyRoleDescriptionOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyRole_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyRoleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyRoleInput {
  _ID_ASC
  _ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountRoleInput {
  name: String
  description: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountRoleOperatorsInput
  OR: [FilterCountRoleInput!]
  AND: [FilterCountRoleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountRoleOperatorsInput {
  description: FilterCountRoleDescriptionOperatorsInput
  _id: FilterCountRole_idOperatorsInput
  createdAt: FilterCountRoleCreatedAtOperatorsInput
}

input FilterCountRoleDescriptionOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountRole_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountRoleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type RoleConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [RoleEdge!]!
}

"""An edge in a connection."""
type RoleEdge {
  """The item at the end of the edge"""
  node: Role!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionRoleEnum {
  _ID_DESC
  _ID_ASC
  DESCRIPTION_DESC
  DESCRIPTION_ASC
}

"""List of items with pagination."""
type RolePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Role!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsSupplierInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  COMPANY_NAME_ASC
  COMPANY_NAME_DESC
  VAT_NUMBER_ASC
  VAT_NUMBER_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneSupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneSupplierOperatorsInput
  OR: [FilterFindOneSupplierInput!]
  AND: [FilterFindOneSupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneSupplierOperatorsInput {
  name: FilterFindOneSupplierNameOperatorsInput
  image: FilterFindOneSupplierImageOperatorsInput
  company_name: FilterFindOneSupplierCompany_nameOperatorsInput
  vat_number: FilterFindOneSupplierVat_numberOperatorsInput
  email: FilterFindOneSupplierEmailOperatorsInput
  phone_number: FilterFindOneSupplierPhone_numberOperatorsInput
  address: FilterFindOneSupplierAddressOperatorsInput
  _id: FilterFindOneSupplier_idOperatorsInput
  createdAt: FilterFindOneSupplierCreatedAtOperatorsInput
}

input FilterFindOneSupplierNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneSupplierImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneSupplierCompany_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneSupplierVat_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindOneSupplierEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneSupplierPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindOneSupplierAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneSupplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneSupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneSupplierInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  COMPANY_NAME_ASC
  COMPANY_NAME_DESC
  VAT_NUMBER_ASC
  VAT_NUMBER_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManySupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManySupplierOperatorsInput
  OR: [FilterFindManySupplierInput!]
  AND: [FilterFindManySupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManySupplierOperatorsInput {
  name: FilterFindManySupplierNameOperatorsInput
  image: FilterFindManySupplierImageOperatorsInput
  company_name: FilterFindManySupplierCompany_nameOperatorsInput
  vat_number: FilterFindManySupplierVat_numberOperatorsInput
  email: FilterFindManySupplierEmailOperatorsInput
  phone_number: FilterFindManySupplierPhone_numberOperatorsInput
  address: FilterFindManySupplierAddressOperatorsInput
  _id: FilterFindManySupplier_idOperatorsInput
  createdAt: FilterFindManySupplierCreatedAtOperatorsInput
}

input FilterFindManySupplierNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManySupplierImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManySupplierCompany_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManySupplierVat_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindManySupplierEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManySupplierPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindManySupplierAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManySupplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManySupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManySupplierInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  COMPANY_NAME_ASC
  COMPANY_NAME_DESC
  VAT_NUMBER_ASC
  VAT_NUMBER_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountSupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountSupplierOperatorsInput
  OR: [FilterCountSupplierInput!]
  AND: [FilterCountSupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountSupplierOperatorsInput {
  name: FilterCountSupplierNameOperatorsInput
  image: FilterCountSupplierImageOperatorsInput
  company_name: FilterCountSupplierCompany_nameOperatorsInput
  vat_number: FilterCountSupplierVat_numberOperatorsInput
  email: FilterCountSupplierEmailOperatorsInput
  phone_number: FilterCountSupplierPhone_numberOperatorsInput
  address: FilterCountSupplierAddressOperatorsInput
  _id: FilterCountSupplier_idOperatorsInput
  createdAt: FilterCountSupplierCreatedAtOperatorsInput
}

input FilterCountSupplierNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountSupplierImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountSupplierCompany_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountSupplierVat_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterCountSupplierEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountSupplierPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterCountSupplierAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountSupplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountSupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type SupplierConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [SupplierEdge!]!
}

"""An edge in a connection."""
type SupplierEdge {
  """The item at the end of the edge"""
  node: Supplier!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionSupplierEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
  IMAGE_DESC
  IMAGE_ASC
  COMPANY_NAME_DESC
  COMPANY_NAME_ASC
  VAT_NUMBER_DESC
  VAT_NUMBER_ASC
  EMAIL_DESC
  EMAIL_ASC
  PHONE_NUMBER_DESC
  PHONE_NUMBER_ASC
  ADDRESS_DESC
  ADDRESS_ASC
}

"""List of items with pagination."""
type SupplierPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Supplier!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsTaxInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneTaxOperatorsInput
  OR: [FilterFindOneTaxInput!]
  AND: [FilterFindOneTaxInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneTaxOperatorsInput {
  name: FilterFindOneTaxNameOperatorsInput
  _id: FilterFindOneTax_idOperatorsInput
  createdAt: FilterFindOneTaxCreatedAtOperatorsInput
}

input FilterFindOneTaxNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneTax_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneTaxCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneTaxInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyTaxOperatorsInput
  OR: [FilterFindManyTaxInput!]
  AND: [FilterFindManyTaxInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyTaxOperatorsInput {
  name: FilterFindManyTaxNameOperatorsInput
  _id: FilterFindManyTax_idOperatorsInput
  createdAt: FilterFindManyTaxCreatedAtOperatorsInput
}

input FilterFindManyTaxNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyTax_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyTaxCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyTaxInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountTaxOperatorsInput
  OR: [FilterCountTaxInput!]
  AND: [FilterCountTaxInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountTaxOperatorsInput {
  name: FilterCountTaxNameOperatorsInput
  _id: FilterCountTax_idOperatorsInput
  createdAt: FilterCountTaxCreatedAtOperatorsInput
}

input FilterCountTaxNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountTax_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountTaxCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type TaxConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [TaxEdge!]!
}

"""An edge in a connection."""
type TaxEdge {
  """The item at the end of the edge"""
  node: Tax!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionTaxEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
}

"""List of items with pagination."""
type TaxPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Tax!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsTransferInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneTransferOperatorsInput
  OR: [FilterFindOneTransferInput!]
  AND: [FilterFindOneTransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneTransferOperatorsInput {
  reference_no: FilterFindOneTransferReference_noOperatorsInput
  document: FilterFindOneTransferDocumentOperatorsInput
  note: FilterFindOneTransferNoteOperatorsInput
  _id: FilterFindOneTransfer_idOperatorsInput
  createdAt: FilterFindOneTransferCreatedAtOperatorsInput
}

input FilterFindOneTransferReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneTransferDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneTransferNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneTransfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneTransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneTransferInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyTransferOperatorsInput
  OR: [FilterFindManyTransferInput!]
  AND: [FilterFindManyTransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyTransferOperatorsInput {
  reference_no: FilterFindManyTransferReference_noOperatorsInput
  document: FilterFindManyTransferDocumentOperatorsInput
  note: FilterFindManyTransferNoteOperatorsInput
  _id: FilterFindManyTransfer_idOperatorsInput
  createdAt: FilterFindManyTransferCreatedAtOperatorsInput
}

input FilterFindManyTransferReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyTransferDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyTransferNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyTransfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyTransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyTransferInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountTransferOperatorsInput
  OR: [FilterCountTransferInput!]
  AND: [FilterCountTransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountTransferOperatorsInput {
  reference_no: FilterCountTransferReference_noOperatorsInput
  document: FilterCountTransferDocumentOperatorsInput
  note: FilterCountTransferNoteOperatorsInput
  _id: FilterCountTransfer_idOperatorsInput
  createdAt: FilterCountTransferCreatedAtOperatorsInput
}

input FilterCountTransferReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountTransferDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountTransferNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountTransfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountTransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type TransferConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [TransferEdge!]!
}

"""An edge in a connection."""
type TransferEdge {
  """The item at the end of the edge"""
  node: Transfer!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionTransferEnum {
  _ID_DESC
  _ID_ASC
  REFERENCE_NO_DESC
  REFERENCE_NO_ASC
  DOCUMENT_DESC
  DOCUMENT_ASC
  NOTE_DESC
  NOTE_ASC
}

"""List of items with pagination."""
type TransferPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Transfer!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsUnitInput {
  _ID_ASC
  _ID_DESC
  UNIT_NAME_ASC
  UNIT_NAME_DESC
  UNIT_CODE_ASC
  UNIT_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneUnitOperatorsInput
  OR: [FilterFindOneUnitInput!]
  AND: [FilterFindOneUnitInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneUnitOperatorsInput {
  unit_name: FilterFindOneUnitUnit_nameOperatorsInput
  unit_code: FilterFindOneUnitUnit_codeOperatorsInput
  _id: FilterFindOneUnit_idOperatorsInput
  createdAt: FilterFindOneUnitCreatedAtOperatorsInput
}

input FilterFindOneUnitUnit_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneUnitUnit_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneUnit_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneUnitCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneUnitInput {
  _ID_ASC
  _ID_DESC
  UNIT_NAME_ASC
  UNIT_NAME_DESC
  UNIT_CODE_ASC
  UNIT_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyUnitOperatorsInput
  OR: [FilterFindManyUnitInput!]
  AND: [FilterFindManyUnitInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyUnitOperatorsInput {
  unit_name: FilterFindManyUnitUnit_nameOperatorsInput
  unit_code: FilterFindManyUnitUnit_codeOperatorsInput
  _id: FilterFindManyUnit_idOperatorsInput
  createdAt: FilterFindManyUnitCreatedAtOperatorsInput
}

input FilterFindManyUnitUnit_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyUnitUnit_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyUnit_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyUnitCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyUnitInput {
  _ID_ASC
  _ID_DESC
  UNIT_NAME_ASC
  UNIT_NAME_DESC
  UNIT_CODE_ASC
  UNIT_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountUnitOperatorsInput
  OR: [FilterCountUnitInput!]
  AND: [FilterCountUnitInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountUnitOperatorsInput {
  unit_name: FilterCountUnitUnit_nameOperatorsInput
  unit_code: FilterCountUnitUnit_codeOperatorsInput
  _id: FilterCountUnit_idOperatorsInput
  createdAt: FilterCountUnitCreatedAtOperatorsInput
}

input FilterCountUnitUnit_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountUnitUnit_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountUnit_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountUnitCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type UnitConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [UnitEdge!]!
}

"""An edge in a connection."""
type UnitEdge {
  """The item at the end of the edge"""
  node: Unit!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionUnitEnum {
  _ID_DESC
  _ID_ASC
  UNIT_NAME_DESC
  UNIT_NAME_ASC
  UNIT_CODE_DESC
  UNIT_CODE_ASC
}

"""List of items with pagination."""
type UnitPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Unit!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

enum SortFindByIdsUserInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindOneUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneUserOperatorsInput
  OR: [FilterFindOneUserInput!]
  AND: [FilterFindOneUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneUserOperatorsInput {
  _id: FilterFindOneUser_idOperatorsInput
  createdAt: FilterFindOneUserCreatedAtOperatorsInput
}

input FilterFindOneUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneUserCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneUserInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyUserOperatorsInput
  OR: [FilterFindManyUserInput!]
  AND: [FilterFindManyUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyUserOperatorsInput {
  _id: FilterFindManyUser_idOperatorsInput
  createdAt: FilterFindManyUserCreatedAtOperatorsInput
}

input FilterFindManyUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyUserCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyUserInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountUserOperatorsInput
  OR: [FilterCountUserInput!]
  AND: [FilterCountUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountUserOperatorsInput {
  _id: FilterCountUser_idOperatorsInput
  createdAt: FilterCountUserCreatedAtOperatorsInput
}

input FilterCountUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountUserCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type UserConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [UserEdge!]!
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge"""
  node: User!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionUserEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type UserPagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [User!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

""""""
input FilterFindOneValueInput {
  name: String
  attribute: MongoID
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneValueOperatorsInput
  OR: [FilterFindOneValueInput!]
  AND: [FilterFindOneValueInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneValueOperatorsInput {
  name: FilterFindOneValueNameOperatorsInput
  _id: FilterFindOneValue_idOperatorsInput
  createdAt: FilterFindOneValueCreatedAtOperatorsInput
}

input FilterFindOneValueNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneValue_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneValueCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneValueInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyValueInput {
  name: String
  attribute: MongoID
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyValueOperatorsInput
  OR: [FilterFindManyValueInput!]
  AND: [FilterFindManyValueInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyValueOperatorsInput {
  name: FilterFindManyValueNameOperatorsInput
  _id: FilterFindManyValue_idOperatorsInput
  createdAt: FilterFindManyValueCreatedAtOperatorsInput
}

input FilterFindManyValueNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyValue_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyValueCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyValueInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountValueInput {
  name: String
  attribute: MongoID
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountValueOperatorsInput
  OR: [FilterCountValueInput!]
  AND: [FilterCountValueInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountValueOperatorsInput {
  name: FilterCountValueNameOperatorsInput
  _id: FilterCountValue_idOperatorsInput
  createdAt: FilterCountValueCreatedAtOperatorsInput
}

input FilterCountValueNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountValue_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountValueCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type ValueConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [ValueEdge!]!
}

"""An edge in a connection."""
type ValueEdge {
  """The item at the end of the edge"""
  node: Value!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionValueEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
}

"""List of items with pagination."""
type ValuePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Value!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

""""""
input FilterFindOneWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneWarehouseOperatorsInput
  OR: [FilterFindOneWarehouseInput!]
  AND: [FilterFindOneWarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneWarehouseOperatorsInput {
  name: FilterFindOneWarehouseNameOperatorsInput
  email: FilterFindOneWarehouseEmailOperatorsInput
  address: FilterFindOneWarehouseAddressOperatorsInput
  phone: FilterFindOneWarehousePhoneOperatorsInput
  _id: FilterFindOneWarehouse_idOperatorsInput
  createdAt: FilterFindOneWarehouseCreatedAtOperatorsInput
}

input FilterFindOneWarehouseNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneWarehouseEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneWarehouseAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindOneWarehousePhoneOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindOneWarehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindOneWarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindOneWarehouseInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  PHONE_ASC
  PHONE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterFindManyWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyWarehouseOperatorsInput
  OR: [FilterFindManyWarehouseInput!]
  AND: [FilterFindManyWarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyWarehouseOperatorsInput {
  name: FilterFindManyWarehouseNameOperatorsInput
  email: FilterFindManyWarehouseEmailOperatorsInput
  address: FilterFindManyWarehouseAddressOperatorsInput
  phone: FilterFindManyWarehousePhoneOperatorsInput
  _id: FilterFindManyWarehouse_idOperatorsInput
  createdAt: FilterFindManyWarehouseCreatedAtOperatorsInput
}

input FilterFindManyWarehouseNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyWarehouseEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyWarehouseAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterFindManyWarehousePhoneOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterFindManyWarehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterFindManyWarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortFindManyWarehouseInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  PHONE_ASC
  PHONE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

""""""
input FilterCountWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountWarehouseOperatorsInput
  OR: [FilterCountWarehouseInput!]
  AND: [FilterCountWarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountWarehouseOperatorsInput {
  name: FilterCountWarehouseNameOperatorsInput
  email: FilterCountWarehouseEmailOperatorsInput
  address: FilterCountWarehouseAddressOperatorsInput
  phone: FilterCountWarehousePhoneOperatorsInput
  _id: FilterCountWarehouse_idOperatorsInput
  createdAt: FilterCountWarehouseCreatedAtOperatorsInput
}

input FilterCountWarehouseNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountWarehouseEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountWarehouseAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterCountWarehousePhoneOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterCountWarehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterCountWarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

"""A connection to a list of items."""
type WarehouseConnection {
  """Total object count."""
  count: Int!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Information to aid in pagination."""
  edges: [WarehouseEdge!]!
}

"""An edge in a connection."""
type WarehouseEdge {
  """The item at the end of the edge"""
  node: Warehouse!

  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionWarehouseEnum {
  _ID_DESC
  _ID_ASC
  NAME_DESC
  NAME_ASC
  EMAIL_DESC
  EMAIL_ASC
  ADDRESS_DESC
  ADDRESS_ASC
  PHONE_DESC
  PHONE_ASC
}

"""List of items with pagination."""
type WarehousePagination {
  """Total object count."""
  count: Int

  """Array of objects."""
  items: [Warehouse!]

  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type Mutation {
  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  accountCreateOne(record: CreateOneAccountInput!): CreateOneAccountPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  accountCreateMany(records: [CreateManyAccountInput!]!): CreateManyAccountPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  accountUpdateById(_id: MongoID!, record: UpdateByIdAccountInput!): UpdateByIdAccountPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  accountUpdateOne(
    record: UpdateOneAccountInput!

    """Filter by fields"""
    filter: FilterUpdateOneAccountInput
    sort: SortUpdateOneAccountInput
    skip: Int
  ): UpdateOneAccountPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  accountUpdateMany(
    record: UpdateManyAccountInput!

    """Filter by fields"""
    filter: FilterUpdateManyAccountInput
    sort: SortUpdateManyAccountInput
    skip: Int
    limit: Int = 100
  ): UpdateManyAccountPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  accountRemoveById(_id: MongoID!): RemoveByIdAccountPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  accountRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneAccountInput
    sort: SortRemoveOneAccountInput
  ): RemoveOneAccountPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  accountRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyAccountInput!
    limit: Int = 100
  ): RemoveManyAccountPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  adjustmentCreateOne(record: CreateOneAdjustmentInput!): CreateOneAdjustmentPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  adjustmentCreateMany(records: [CreateManyAdjustmentInput!]!): CreateManyAdjustmentPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  adjustmentUpdateById(_id: MongoID!, record: UpdateByIdAdjustmentInput!): UpdateByIdAdjustmentPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  adjustmentUpdateOne(
    record: UpdateOneAdjustmentInput!

    """Filter by fields"""
    filter: FilterUpdateOneAdjustmentInput
    sort: SortUpdateOneAdjustmentInput
    skip: Int
  ): UpdateOneAdjustmentPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  adjustmentUpdateMany(
    record: UpdateManyAdjustmentInput!

    """Filter by fields"""
    filter: FilterUpdateManyAdjustmentInput
    sort: SortUpdateManyAdjustmentInput
    skip: Int
    limit: Int = 100
  ): UpdateManyAdjustmentPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  adjustmentRemoveById(_id: MongoID!): RemoveByIdAdjustmentPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  adjustmentRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneAdjustmentInput
    sort: SortRemoveOneAdjustmentInput
  ): RemoveOneAdjustmentPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  adjustmentRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyAdjustmentInput!
    limit: Int = 100
  ): RemoveManyAdjustmentPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  attributeCreateOne(record: CreateOneAttributeInput!): CreateOneAttributePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  attributeCreateMany(records: [CreateManyAttributeInput!]!): CreateManyAttributePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  attributeUpdateById(_id: MongoID!, record: UpdateByIdAttributeInput!): UpdateByIdAttributePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  attributeUpdateOne(
    record: UpdateOneAttributeInput!

    """Filter by fields"""
    filter: FilterUpdateOneAttributeInput
    sort: SortUpdateOneAttributeInput
    skip: Int
  ): UpdateOneAttributePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  attributeUpdateMany(
    record: UpdateManyAttributeInput!

    """Filter by fields"""
    filter: FilterUpdateManyAttributeInput
    sort: SortUpdateManyAttributeInput
    skip: Int
    limit: Int = 100
  ): UpdateManyAttributePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  attributeRemoveById(_id: MongoID!): RemoveByIdAttributePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  attributeRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneAttributeInput
    sort: SortRemoveOneAttributeInput
  ): RemoveOneAttributePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  attributeRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyAttributeInput!
    limit: Int = 100
  ): RemoveManyAttributePayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  brandCreateOne(record: CreateOneBrandInput!): CreateOneBrandPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  brandCreateMany(records: [CreateManyBrandInput!]!): CreateManyBrandPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  brandUpdateById(_id: MongoID!, record: UpdateByIdBrandInput!): UpdateByIdBrandPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  brandUpdateOne(
    record: UpdateOneBrandInput!

    """Filter by fields"""
    filter: FilterUpdateOneBrandInput
    sort: SortUpdateOneBrandInput
    skip: Int
  ): UpdateOneBrandPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  brandUpdateMany(
    record: UpdateManyBrandInput!

    """Filter by fields"""
    filter: FilterUpdateManyBrandInput
    sort: SortUpdateManyBrandInput
    skip: Int
    limit: Int = 100
  ): UpdateManyBrandPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  brandRemoveById(_id: MongoID!): RemoveByIdBrandPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  brandRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneBrandInput
    sort: SortRemoveOneBrandInput
  ): RemoveOneBrandPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  brandRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyBrandInput!
    limit: Int = 100
  ): RemoveManyBrandPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  categoryCreateOne(record: CreateOneCategoryInput!): CreateOneCategoryPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  categoryCreateMany(records: [CreateManyCategoryInput!]!): CreateManyCategoryPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  categoryUpdateById(_id: MongoID!, record: UpdateByIdCategoryInput!): UpdateByIdCategoryPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  categoryUpdateOne(
    record: UpdateOneCategoryInput!

    """Filter by fields"""
    filter: FilterUpdateOneCategoryInput
    sort: SortUpdateOneCategoryInput
    skip: Int
  ): UpdateOneCategoryPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  categoryUpdateMany(
    record: UpdateManyCategoryInput!

    """Filter by fields"""
    filter: FilterUpdateManyCategoryInput
    sort: SortUpdateManyCategoryInput
    skip: Int
    limit: Int = 100
  ): UpdateManyCategoryPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  categoryRemoveById(_id: MongoID!): RemoveByIdCategoryPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  categoryRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneCategoryInput
    sort: SortRemoveOneCategoryInput
  ): RemoveOneCategoryPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  categoryRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyCategoryInput!
    limit: Int = 100
  ): RemoveManyCategoryPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  couponCreateOne(record: CreateOneCouponInput!): CreateOneCouponPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  couponCreateMany(records: [CreateManyCouponInput!]!): CreateManyCouponPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  couponUpdateById(_id: MongoID!, record: UpdateByIdCouponInput!): UpdateByIdCouponPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  couponUpdateOne(
    record: UpdateOneCouponInput!

    """Filter by fields"""
    filter: FilterUpdateOneCouponInput
    sort: SortUpdateOneCouponInput
    skip: Int
  ): UpdateOneCouponPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  couponUpdateMany(
    record: UpdateManyCouponInput!

    """Filter by fields"""
    filter: FilterUpdateManyCouponInput
    sort: SortUpdateManyCouponInput
    skip: Int
    limit: Int = 100
  ): UpdateManyCouponPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  couponRemoveById(_id: MongoID!): RemoveByIdCouponPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  couponRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneCouponInput
    sort: SortRemoveOneCouponInput
  ): RemoveOneCouponPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  couponRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyCouponInput!
    limit: Int = 100
  ): RemoveManyCouponPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  customerCreateOne(record: CreateOneCustomerInput!): CreateOneCustomerPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  customerCreateMany(records: [CreateManyCustomerInput!]!): CreateManyCustomerPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  customerUpdateById(_id: MongoID!, record: UpdateByIdCustomerInput!): UpdateByIdCustomerPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  customerUpdateOne(
    record: UpdateOneCustomerInput!

    """Filter by fields"""
    filter: FilterUpdateOneCustomerInput
    sort: SortUpdateOneCustomerInput
    skip: Int
  ): UpdateOneCustomerPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  customerUpdateMany(
    record: UpdateManyCustomerInput!

    """Filter by fields"""
    filter: FilterUpdateManyCustomerInput
    sort: SortUpdateManyCustomerInput
    skip: Int
    limit: Int = 100
  ): UpdateManyCustomerPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  customerRemoveById(_id: MongoID!): RemoveByIdCustomerPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  customerRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneCustomerInput
    sort: SortRemoveOneCustomerInput
  ): RemoveOneCustomerPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  customerRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyCustomerInput!
    limit: Int = 100
  ): RemoveManyCustomerPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  customerGroupCreateOne(record: CreateOneCustomer_GroupInput!): CreateOneCustomer_GroupPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  customerGroupCreateMany(records: [CreateManyCustomer_GroupInput!]!): CreateManyCustomer_GroupPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  customerGroupUpdateById(_id: MongoID!, record: UpdateByIdCustomer_GroupInput!): UpdateByIdCustomer_GroupPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  customerGroupUpdateOne(
    record: UpdateOneCustomer_GroupInput!

    """Filter by fields"""
    filter: FilterUpdateOneCustomer_GroupInput
    sort: SortUpdateOneCustomer_GroupInput
    skip: Int
  ): UpdateOneCustomer_GroupPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  customerGroupUpdateMany(
    record: UpdateManyCustomer_GroupInput!

    """Filter by fields"""
    filter: FilterUpdateManyCustomer_GroupInput
    sort: SortUpdateManyCustomer_GroupInput
    skip: Int
    limit: Int = 100
  ): UpdateManyCustomer_GroupPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  customerGroupRemoveById(_id: MongoID!): RemoveByIdCustomer_GroupPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  customerGroupRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneCustomer_GroupInput
    sort: SortRemoveOneCustomer_GroupInput
  ): RemoveOneCustomer_GroupPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  customerGroupRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyCustomer_GroupInput!
    limit: Int = 100
  ): RemoveManyCustomer_GroupPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  departmentCreateOne(record: CreateOneDepartmentInput!): CreateOneDepartmentPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  departmentCreateMany(records: [CreateManyDepartmentInput!]!): CreateManyDepartmentPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  departmentUpdateById(_id: MongoID!, record: UpdateByIdDepartmentInput!): UpdateByIdDepartmentPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  departmentUpdateOne(
    record: UpdateOneDepartmentInput!

    """Filter by fields"""
    filter: FilterUpdateOneDepartmentInput
    sort: SortUpdateOneDepartmentInput
    skip: Int
  ): UpdateOneDepartmentPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  departmentUpdateMany(
    record: UpdateManyDepartmentInput!

    """Filter by fields"""
    filter: FilterUpdateManyDepartmentInput
    sort: SortUpdateManyDepartmentInput
    skip: Int
    limit: Int = 100
  ): UpdateManyDepartmentPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  departmentRemoveById(_id: MongoID!): RemoveByIdDepartmentPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  departmentRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneDepartmentInput
    sort: SortRemoveOneDepartmentInput
  ): RemoveOneDepartmentPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  departmentRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyDepartmentInput!
    limit: Int = 100
  ): RemoveManyDepartmentPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  EmployeeCreateOne(record: CreateOneEmployeeInput!): CreateOneEmployeePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  EmployeeCreateMany(records: [CreateManyEmployeeInput!]!): CreateManyEmployeePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  EmployeeUpdateById(_id: MongoID!, record: UpdateByIdEmployeeInput!): UpdateByIdEmployeePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  EmployeeUpdateOne(
    record: UpdateOneEmployeeInput!

    """Filter by fields"""
    filter: FilterUpdateOneEmployeeInput
    sort: SortUpdateOneEmployeeInput
    skip: Int
  ): UpdateOneEmployeePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  EmployeeUpdateMany(
    record: UpdateManyEmployeeInput!

    """Filter by fields"""
    filter: FilterUpdateManyEmployeeInput
    sort: SortUpdateManyEmployeeInput
    skip: Int
    limit: Int = 100
  ): UpdateManyEmployeePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  EmployeeRemoveById(_id: MongoID!): RemoveByIdEmployeePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  EmployeeRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneEmployeeInput
    sort: SortRemoveOneEmployeeInput
  ): RemoveOneEmployeePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  EmployeeRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyEmployeeInput!
    limit: Int = 100
  ): RemoveManyEmployeePayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  productAdjustmentCreateOne(record: CreateOneProduct_AdjustmentInput!): CreateOneProduct_AdjustmentPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  productAdjustmentCreateMany(records: [CreateManyProduct_AdjustmentInput!]!): CreateManyProduct_AdjustmentPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productAdjustmentUpdateById(_id: MongoID!, record: UpdateByIdProduct_AdjustmentInput!): UpdateByIdProduct_AdjustmentPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productAdjustmentUpdateOne(
    record: UpdateOneProduct_AdjustmentInput!

    """Filter by fields"""
    filter: FilterUpdateOneProduct_AdjustmentInput
    sort: SortUpdateOneProduct_AdjustmentInput
    skip: Int
  ): UpdateOneProduct_AdjustmentPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productAdjustmentUpdateMany(
    record: UpdateManyProduct_AdjustmentInput!

    """Filter by fields"""
    filter: FilterUpdateManyProduct_AdjustmentInput
    sort: SortUpdateManyProduct_AdjustmentInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProduct_AdjustmentPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  productAdjustmentRemoveById(_id: MongoID!): RemoveByIdProduct_AdjustmentPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  productAdjustmentRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProduct_AdjustmentInput
    sort: SortRemoveOneProduct_AdjustmentInput
  ): RemoveOneProduct_AdjustmentPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productAdjustmentRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProduct_AdjustmentInput!
    limit: Int = 100
  ): RemoveManyProduct_AdjustmentPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  productPurchaseCreateOne(record: CreateOneProduct_PurchaseInput!): CreateOneProduct_PurchasePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  productPurchaseCreateMany(records: [CreateManyProduct_PurchaseInput!]!): CreateManyProduct_PurchasePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productPurchaseUpdateById(_id: MongoID!, record: UpdateByIdProduct_PurchaseInput!): UpdateByIdProduct_PurchasePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productPurchaseUpdateOne(
    record: UpdateOneProduct_PurchaseInput!

    """Filter by fields"""
    filter: FilterUpdateOneProduct_PurchaseInput
    sort: SortUpdateOneProduct_PurchaseInput
    skip: Int
  ): UpdateOneProduct_PurchasePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productPurchaseUpdateMany(
    record: UpdateManyProduct_PurchaseInput!

    """Filter by fields"""
    filter: FilterUpdateManyProduct_PurchaseInput
    sort: SortUpdateManyProduct_PurchaseInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProduct_PurchasePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  productPurchaseRemoveById(_id: MongoID!): RemoveByIdProduct_PurchasePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  productPurchaseRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProduct_PurchaseInput
    sort: SortRemoveOneProduct_PurchaseInput
  ): RemoveOneProduct_PurchasePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productPurchaseRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProduct_PurchaseInput!
    limit: Int = 100
  ): RemoveManyProduct_PurchasePayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  productQuotationCreateOne(record: CreateOneProduct_QuotationInput!): CreateOneProduct_QuotationPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  productQuotationCreateMany(records: [CreateManyProduct_QuotationInput!]!): CreateManyProduct_QuotationPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productQuotationUpdateById(_id: MongoID!, record: UpdateByIdProduct_QuotationInput!): UpdateByIdProduct_QuotationPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productQuotationUpdateOne(
    record: UpdateOneProduct_QuotationInput!

    """Filter by fields"""
    filter: FilterUpdateOneProduct_QuotationInput
    sort: SortUpdateOneProduct_QuotationInput
    skip: Int
  ): UpdateOneProduct_QuotationPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productQuotationUpdateMany(
    record: UpdateManyProduct_QuotationInput!

    """Filter by fields"""
    filter: FilterUpdateManyProduct_QuotationInput
    sort: SortUpdateManyProduct_QuotationInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProduct_QuotationPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  productQuotationRemoveById(_id: MongoID!): RemoveByIdProduct_QuotationPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  productQuotationRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProduct_QuotationInput
    sort: SortRemoveOneProduct_QuotationInput
  ): RemoveOneProduct_QuotationPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productQuotationRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProduct_QuotationInput!
    limit: Int = 100
  ): RemoveManyProduct_QuotationPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  productReturnCreateOne(record: CreateOneProduct_ReturnInput!): CreateOneProduct_ReturnPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  productReturnCreateMany(records: [CreateManyProduct_ReturnInput!]!): CreateManyProduct_ReturnPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productReturnUpdateById(_id: MongoID!, record: UpdateByIdProduct_ReturnInput!): UpdateByIdProduct_ReturnPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productReturnUpdateOne(
    record: UpdateOneProduct_ReturnInput!

    """Filter by fields"""
    filter: FilterUpdateOneProduct_ReturnInput
    sort: SortUpdateOneProduct_ReturnInput
    skip: Int
  ): UpdateOneProduct_ReturnPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productReturnUpdateMany(
    record: UpdateManyProduct_ReturnInput!

    """Filter by fields"""
    filter: FilterUpdateManyProduct_ReturnInput
    sort: SortUpdateManyProduct_ReturnInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProduct_ReturnPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  productReturnRemoveById(_id: MongoID!): RemoveByIdProduct_ReturnPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  productReturnRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProduct_ReturnInput
    sort: SortRemoveOneProduct_ReturnInput
  ): RemoveOneProduct_ReturnPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productReturnRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProduct_ReturnInput!
    limit: Int = 100
  ): RemoveManyProduct_ReturnPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  productSaleCreateOne(record: CreateOneProduct_SaleInput!): CreateOneProduct_SalePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  productSaleCreateMany(records: [CreateManyProduct_SaleInput!]!): CreateManyProduct_SalePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productSaleUpdateById(_id: MongoID!, record: UpdateByIdProduct_SaleInput!): UpdateByIdProduct_SalePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productSaleUpdateOne(
    record: UpdateOneProduct_SaleInput!

    """Filter by fields"""
    filter: FilterUpdateOneProduct_SaleInput
    sort: SortUpdateOneProduct_SaleInput
    skip: Int
  ): UpdateOneProduct_SalePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productSaleUpdateMany(
    record: UpdateManyProduct_SaleInput!

    """Filter by fields"""
    filter: FilterUpdateManyProduct_SaleInput
    sort: SortUpdateManyProduct_SaleInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProduct_SalePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  productSaleRemoveById(_id: MongoID!): RemoveByIdProduct_SalePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  productSaleRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProduct_SaleInput
    sort: SortRemoveOneProduct_SaleInput
  ): RemoveOneProduct_SalePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productSaleRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProduct_SaleInput!
    limit: Int = 100
  ): RemoveManyProduct_SalePayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  productSupplierCreateOne(record: CreateOneProduct_SupplierInput!): CreateOneProduct_SupplierPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  productSupplierCreateMany(records: [CreateManyProduct_SupplierInput!]!): CreateManyProduct_SupplierPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productSupplierUpdateById(_id: MongoID!, record: UpdateByIdProduct_SupplierInput!): UpdateByIdProduct_SupplierPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productSupplierUpdateOne(
    record: UpdateOneProduct_SupplierInput!

    """Filter by fields"""
    filter: FilterUpdateOneProduct_SupplierInput
    sort: SortUpdateOneProduct_SupplierInput
    skip: Int
  ): UpdateOneProduct_SupplierPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productSupplierUpdateMany(
    record: UpdateManyProduct_SupplierInput!

    """Filter by fields"""
    filter: FilterUpdateManyProduct_SupplierInput
    sort: SortUpdateManyProduct_SupplierInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProduct_SupplierPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  productSupplierRemoveById(_id: MongoID!): RemoveByIdProduct_SupplierPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  productSupplierRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProduct_SupplierInput
    sort: SortRemoveOneProduct_SupplierInput
  ): RemoveOneProduct_SupplierPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productSupplierRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProduct_SupplierInput!
    limit: Int = 100
  ): RemoveManyProduct_SupplierPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  ProductTransferCreateOne(record: CreateOneProduct_TransferInput!): CreateOneProduct_TransferPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  ProductTransferCreateMany(records: [CreateManyProduct_TransferInput!]!): CreateManyProduct_TransferPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  ProductTransferUpdateById(_id: MongoID!, record: UpdateByIdProduct_TransferInput!): UpdateByIdProduct_TransferPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  ProductTransferUpdateOne(
    record: UpdateOneProduct_TransferInput!

    """Filter by fields"""
    filter: FilterUpdateOneProduct_TransferInput
    sort: SortUpdateOneProduct_TransferInput
    skip: Int
  ): UpdateOneProduct_TransferPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  ProductTransferUpdateMany(
    record: UpdateManyProduct_TransferInput!

    """Filter by fields"""
    filter: FilterUpdateManyProduct_TransferInput
    sort: SortUpdateManyProduct_TransferInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProduct_TransferPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  ProductTransferRemoveById(_id: MongoID!): RemoveByIdProduct_TransferPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  ProductTransferRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProduct_TransferInput
    sort: SortRemoveOneProduct_TransferInput
  ): RemoveOneProduct_TransferPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  ProductTransferRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProduct_TransferInput!
    limit: Int = 100
  ): RemoveManyProduct_TransferPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  productVariantCreateOne(record: CreateOneProduct_VariantInput!): CreateOneProduct_VariantPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  productVariantCreateMany(records: [CreateManyProduct_VariantInput!]!): CreateManyProduct_VariantPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productVariantUpdateById(_id: MongoID!, record: UpdateByIdProduct_VariantInput!): UpdateByIdProduct_VariantPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productVariantUpdateOne(
    record: UpdateOneProduct_VariantInput!

    """Filter by fields"""
    filter: FilterUpdateOneProduct_VariantInput
    sort: SortUpdateOneProduct_VariantInput
    skip: Int
  ): UpdateOneProduct_VariantPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productVariantUpdateMany(
    record: UpdateManyProduct_VariantInput!

    """Filter by fields"""
    filter: FilterUpdateManyProduct_VariantInput
    sort: SortUpdateManyProduct_VariantInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProduct_VariantPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  productVariantRemoveById(_id: MongoID!): RemoveByIdProduct_VariantPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  productVariantRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProduct_VariantInput
    sort: SortRemoveOneProduct_VariantInput
  ): RemoveOneProduct_VariantPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productVariantRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProduct_VariantInput!
    limit: Int = 100
  ): RemoveManyProduct_VariantPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  productWarehouseCreateOne(record: CreateOneProduct_WarehouseInput!): CreateOneProduct_WarehousePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  productWarehouseCreateMany(records: [CreateManyProduct_WarehouseInput!]!): CreateManyProduct_WarehousePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productWarehouseUpdateById(_id: MongoID!, record: UpdateByIdProduct_WarehouseInput!): UpdateByIdProduct_WarehousePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productWarehouseUpdateOne(
    record: UpdateOneProduct_WarehouseInput!

    """Filter by fields"""
    filter: FilterUpdateOneProduct_WarehouseInput
    sort: SortUpdateOneProduct_WarehouseInput
    skip: Int
  ): UpdateOneProduct_WarehousePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productWarehouseUpdateMany(
    record: UpdateManyProduct_WarehouseInput!

    """Filter by fields"""
    filter: FilterUpdateManyProduct_WarehouseInput
    sort: SortUpdateManyProduct_WarehouseInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProduct_WarehousePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  productWarehouseRemoveById(_id: MongoID!): RemoveByIdProduct_WarehousePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  productWarehouseRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProduct_WarehouseInput
    sort: SortRemoveOneProduct_WarehouseInput
  ): RemoveOneProduct_WarehousePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productWarehouseRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProduct_WarehouseInput!
    limit: Int = 100
  ): RemoveManyProduct_WarehousePayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  productCreateOne(record: CreateOneProductInput!): CreateOneProductPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  productCreateMany(records: [CreateManyProductInput!]!): CreateManyProductPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productUpdateById(_id: MongoID!, record: UpdateByIdProductInput!): UpdateByIdProductPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  productUpdateOne(
    record: UpdateOneProductInput!

    """Filter by fields"""
    filter: FilterUpdateOneProductInput
    sort: SortUpdateOneProductInput
    skip: Int
  ): UpdateOneProductPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productUpdateMany(
    record: UpdateManyProductInput!

    """Filter by fields"""
    filter: FilterUpdateManyProductInput
    sort: SortUpdateManyProductInput
    skip: Int
    limit: Int = 100
  ): UpdateManyProductPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  productRemoveById(_id: MongoID!): RemoveByIdProductPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  productRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneProductInput
    sort: SortRemoveOneProductInput
  ): RemoveOneProductPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  productRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyProductInput!
    limit: Int = 100
  ): RemoveManyProductPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  purchaseCreateOne(record: CreateOnePurchaseInput!): CreateOnePurchasePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  purchaseCreateMany(records: [CreateManyPurchaseInput!]!): CreateManyPurchasePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  purchaseUpdateById(_id: MongoID!, record: UpdateByIdPurchaseInput!): UpdateByIdPurchasePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  purchaseUpdateOne(
    record: UpdateOnePurchaseInput!

    """Filter by fields"""
    filter: FilterUpdateOnePurchaseInput
    sort: SortUpdateOnePurchaseInput
    skip: Int
  ): UpdateOnePurchasePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  purchaseUpdateMany(
    record: UpdateManyPurchaseInput!

    """Filter by fields"""
    filter: FilterUpdateManyPurchaseInput
    sort: SortUpdateManyPurchaseInput
    skip: Int
    limit: Int = 100
  ): UpdateManyPurchasePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  purchaseRemoveById(_id: MongoID!): RemoveByIdPurchasePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  purchaseRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOnePurchaseInput
    sort: SortRemoveOnePurchaseInput
  ): RemoveOnePurchasePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  purchaseRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyPurchaseInput!
    limit: Int = 100
  ): RemoveManyPurchasePayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  returnCreateOne(record: CreateOneReturnInput!): CreateOneReturnPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  returnCreateMany(records: [CreateManyReturnInput!]!): CreateManyReturnPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  returnUpdateById(_id: MongoID!, record: UpdateByIdReturnInput!): UpdateByIdReturnPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  returnUpdateOne(
    record: UpdateOneReturnInput!

    """Filter by fields"""
    filter: FilterUpdateOneReturnInput
    sort: SortUpdateOneReturnInput
    skip: Int
  ): UpdateOneReturnPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  returnUpdateMany(
    record: UpdateManyReturnInput!

    """Filter by fields"""
    filter: FilterUpdateManyReturnInput
    sort: SortUpdateManyReturnInput
    skip: Int
    limit: Int = 100
  ): UpdateManyReturnPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  returnRemoveById(_id: MongoID!): RemoveByIdReturnPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  returnRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneReturnInput
    sort: SortRemoveOneReturnInput
  ): RemoveOneReturnPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  returnRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyReturnInput!
    limit: Int = 100
  ): RemoveManyReturnPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  quotationCreateOne(record: CreateOneQuotationInput!): CreateOneQuotationPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  quotationCreateMany(records: [CreateManyQuotationInput!]!): CreateManyQuotationPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  quotationUpdateById(_id: MongoID!, record: UpdateByIdQuotationInput!): UpdateByIdQuotationPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  quotationUpdateOne(
    record: UpdateOneQuotationInput!

    """Filter by fields"""
    filter: FilterUpdateOneQuotationInput
    sort: SortUpdateOneQuotationInput
    skip: Int
  ): UpdateOneQuotationPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  quotationUpdateMany(
    record: UpdateManyQuotationInput!

    """Filter by fields"""
    filter: FilterUpdateManyQuotationInput
    sort: SortUpdateManyQuotationInput
    skip: Int
    limit: Int = 100
  ): UpdateManyQuotationPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  quotationRemoveById(_id: MongoID!): RemoveByIdQuotationPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  quotationRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneQuotationInput
    sort: SortRemoveOneQuotationInput
  ): RemoveOneQuotationPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  quotationRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyQuotationInput!
    limit: Int = 100
  ): RemoveManyQuotationPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  roleCreateOne(record: CreateOneRoleInput!): CreateOneRolePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  roleCreateMany(records: [CreateManyRoleInput!]!): CreateManyRolePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  roleUpdateById(_id: MongoID!, record: UpdateByIdRoleInput!): UpdateByIdRolePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  roleUpdateOne(
    record: UpdateOneRoleInput!

    """Filter by fields"""
    filter: FilterUpdateOneRoleInput
    sort: SortUpdateOneRoleInput
    skip: Int
  ): UpdateOneRolePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  roleUpdateMany(
    record: UpdateManyRoleInput!

    """Filter by fields"""
    filter: FilterUpdateManyRoleInput
    sort: SortUpdateManyRoleInput
    skip: Int
    limit: Int = 100
  ): UpdateManyRolePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  roleRemoveById(_id: MongoID!): RemoveByIdRolePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  roleRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneRoleInput
    sort: SortRemoveOneRoleInput
  ): RemoveOneRolePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  roleRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyRoleInput!
    limit: Int = 100
  ): RemoveManyRolePayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  supplierCreateOne(record: CreateOneSupplierInput!): CreateOneSupplierPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  supplierCreateMany(records: [CreateManySupplierInput!]!): CreateManySupplierPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  supplierUpdateById(_id: MongoID!, record: UpdateByIdSupplierInput!): UpdateByIdSupplierPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  supplierUpdateOne(
    record: UpdateOneSupplierInput!

    """Filter by fields"""
    filter: FilterUpdateOneSupplierInput
    sort: SortUpdateOneSupplierInput
    skip: Int
  ): UpdateOneSupplierPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  supplierUpdateMany(
    record: UpdateManySupplierInput!

    """Filter by fields"""
    filter: FilterUpdateManySupplierInput
    sort: SortUpdateManySupplierInput
    skip: Int
    limit: Int = 100
  ): UpdateManySupplierPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  supplierRemoveById(_id: MongoID!): RemoveByIdSupplierPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  supplierRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneSupplierInput
    sort: SortRemoveOneSupplierInput
  ): RemoveOneSupplierPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  supplierRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManySupplierInput!
    limit: Int = 100
  ): RemoveManySupplierPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  taxCreateOne(record: CreateOneTaxInput!): CreateOneTaxPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  taxCreateMany(records: [CreateManyTaxInput!]!): CreateManyTaxPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  taxUpdateById(_id: MongoID!, record: UpdateByIdTaxInput!): UpdateByIdTaxPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  taxUpdateOne(
    record: UpdateOneTaxInput!

    """Filter by fields"""
    filter: FilterUpdateOneTaxInput
    sort: SortUpdateOneTaxInput
    skip: Int
  ): UpdateOneTaxPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  taxUpdateMany(
    record: UpdateManyTaxInput!

    """Filter by fields"""
    filter: FilterUpdateManyTaxInput
    sort: SortUpdateManyTaxInput
    skip: Int
    limit: Int = 100
  ): UpdateManyTaxPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  taxRemoveById(_id: MongoID!): RemoveByIdTaxPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  taxRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneTaxInput
    sort: SortRemoveOneTaxInput
  ): RemoveOneTaxPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  taxRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyTaxInput!
    limit: Int = 100
  ): RemoveManyTaxPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  transferCreateOne(record: CreateOneTransferInput!): CreateOneTransferPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  transferCreateMany(records: [CreateManyTransferInput!]!): CreateManyTransferPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  transferUpdateById(_id: MongoID!, record: UpdateByIdTransferInput!): UpdateByIdTransferPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  transferUpdateOne(
    record: UpdateOneTransferInput!

    """Filter by fields"""
    filter: FilterUpdateOneTransferInput
    sort: SortUpdateOneTransferInput
    skip: Int
  ): UpdateOneTransferPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  transferUpdateMany(
    record: UpdateManyTransferInput!

    """Filter by fields"""
    filter: FilterUpdateManyTransferInput
    sort: SortUpdateManyTransferInput
    skip: Int
    limit: Int = 100
  ): UpdateManyTransferPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  transferRemoveById(_id: MongoID!): RemoveByIdTransferPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  transferRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneTransferInput
    sort: SortRemoveOneTransferInput
  ): RemoveOneTransferPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  transferRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyTransferInput!
    limit: Int = 100
  ): RemoveManyTransferPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  unitCreateOne(record: CreateOneUnitInput!): CreateOneUnitPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  unitCreateMany(records: [CreateManyUnitInput!]!): CreateManyUnitPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  unitUpdateById(_id: MongoID!, record: UpdateByIdUnitInput!): UpdateByIdUnitPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  unitUpdateOne(
    record: UpdateOneUnitInput!

    """Filter by fields"""
    filter: FilterUpdateOneUnitInput
    sort: SortUpdateOneUnitInput
    skip: Int
  ): UpdateOneUnitPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  unitUpdateMany(
    record: UpdateManyUnitInput!

    """Filter by fields"""
    filter: FilterUpdateManyUnitInput
    sort: SortUpdateManyUnitInput
    skip: Int
    limit: Int = 100
  ): UpdateManyUnitPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  unitRemoveById(_id: MongoID!): RemoveByIdUnitPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  unitRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneUnitInput
    sort: SortRemoveOneUnitInput
  ): RemoveOneUnitPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  unitRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyUnitInput!
    limit: Int = 100
  ): RemoveManyUnitPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  userCreateOne(record: CreateOneUserInput!): CreateOneUserPayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  userCreateMany(records: [CreateManyUserInput!]!): CreateManyUserPayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  userUpdateById(_id: MongoID!, record: UpdateByIdUserInput!): UpdateByIdUserPayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  userUpdateOne(
    record: UpdateOneUserInput!

    """Filter by fields"""
    filter: FilterUpdateOneUserInput
    sort: SortUpdateOneUserInput
    skip: Int
  ): UpdateOneUserPayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  userUpdateMany(
    record: UpdateManyUserInput!

    """Filter by fields"""
    filter: FilterUpdateManyUserInput
    sort: SortUpdateManyUserInput
    skip: Int
    limit: Int = 100
  ): UpdateManyUserPayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  userRemoveById(_id: MongoID!): RemoveByIdUserPayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  userRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneUserInput
    sort: SortRemoveOneUserInput
  ): RemoveOneUserPayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  userRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyUserInput!
    limit: Int = 100
  ): RemoveManyUserPayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  valueCreateOne(record: CreateOneValueInput!): CreateOneValuePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  valueCreateMany(records: [CreateManyValueInput!]!): CreateManyValuePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  valueUpdateById(_id: MongoID!, record: UpdateByIdValueInput!): UpdateByIdValuePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  valueUpdateOne(
    record: UpdateOneValueInput!

    """Filter by fields"""
    filter: FilterUpdateOneValueInput
    sort: SortUpdateOneValueInput
    skip: Int
  ): UpdateOneValuePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  valueUpdateMany(
    record: UpdateManyValueInput!

    """Filter by fields"""
    filter: FilterUpdateManyValueInput
    sort: SortUpdateManyValueInput
    skip: Int
    limit: Int = 100
  ): UpdateManyValuePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  valueRemoveById(_id: MongoID!): RemoveByIdValuePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  valueRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneValueInput
    sort: SortRemoveOneValueInput
  ): RemoveOneValuePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  valueRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyValueInput!
    limit: Int = 100
  ): RemoveManyValuePayload

  """
  Create one document with mongoose defaults, setters, hooks and validation
  """
  warehouseCreateOne(record: CreateOneWarehouseInput!): CreateOneWarehousePayload

  """
  Creates Many documents with mongoose defaults, setters, hooks and validation
  """
  warehouseCreateMany(records: [CreateManyWarehouseInput!]!): CreateManyWarehousePayload

  """
  Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  warehouseUpdateById(_id: MongoID!, record: UpdateByIdWarehouseInput!): UpdateByIdWarehousePayload

  """
  Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it.
  """
  warehouseUpdateOne(
    record: UpdateOneWarehouseInput!

    """Filter by fields"""
    filter: FilterUpdateOneWarehouseInput
    sort: SortUpdateOneWarehouseInput
    skip: Int
  ): UpdateOneWarehousePayload

  """
  Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  warehouseUpdateMany(
    record: UpdateManyWarehouseInput!

    """Filter by fields"""
    filter: FilterUpdateManyWarehouseInput
    sort: SortUpdateManyWarehouseInput
    skip: Int
    limit: Int = 100
  ): UpdateManyWarehousePayload

  """
  Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document.
  """
  warehouseRemoveById(_id: MongoID!): RemoveByIdWarehousePayload

  """
  Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document.
  """
  warehouseRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneWarehouseInput
    sort: SortRemoveOneWarehouseInput
  ): RemoveOneWarehousePayload

  """
  Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. 
  """
  warehouseRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyWarehouseInput!
    limit: Int = 100
  ): RemoveManyWarehousePayload
}

type CreateOneAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

interface ErrorInterface {
  """Generic error message"""
  message: String
}

""""""
input CreateOneAccountInput {
  account_no: String!
  name: String!
  initial_balance: Float!
  total_Balance: Float!
  note: String
  is_default: Boolean!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyAccountPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Account!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyAccountInput {
  account_no: String!
  name: String!
  initial_balance: Float!
  total_Balance: Float!
  note: String
  is_default: Boolean!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneAccountOperatorsInput
  OR: [FilterUpdateOneAccountInput!]
  AND: [FilterUpdateOneAccountInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneAccountOperatorsInput {
  account_no: FilterUpdateOneAccountAccount_noOperatorsInput
  name: FilterUpdateOneAccountNameOperatorsInput
  note: FilterUpdateOneAccountNoteOperatorsInput
  _id: FilterUpdateOneAccount_idOperatorsInput
  createdAt: FilterUpdateOneAccountCreatedAtOperatorsInput
}

input FilterUpdateOneAccountAccount_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneAccountNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneAccountNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneAccountCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneAccountInput {
  _ID_ASC
  _ID_DESC
  ACCOUNT_NO_ASC
  ACCOUNT_NO_DESC
  NAME_ASC
  NAME_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyAccountPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyAccountOperatorsInput
  OR: [FilterUpdateManyAccountInput!]
  AND: [FilterUpdateManyAccountInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyAccountOperatorsInput {
  account_no: FilterUpdateManyAccountAccount_noOperatorsInput
  name: FilterUpdateManyAccountNameOperatorsInput
  note: FilterUpdateManyAccountNoteOperatorsInput
  _id: FilterUpdateManyAccount_idOperatorsInput
  createdAt: FilterUpdateManyAccountCreatedAtOperatorsInput
}

input FilterUpdateManyAccountAccount_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyAccountNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyAccountNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyAccountCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyAccountInput {
  _ID_ASC
  _ID_DESC
  ACCOUNT_NO_ASC
  ACCOUNT_NO_DESC
  NAME_ASC
  NAME_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneAccountPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Account

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneAccountOperatorsInput
  OR: [FilterRemoveOneAccountInput!]
  AND: [FilterRemoveOneAccountInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneAccountOperatorsInput {
  account_no: FilterRemoveOneAccountAccount_noOperatorsInput
  name: FilterRemoveOneAccountNameOperatorsInput
  note: FilterRemoveOneAccountNoteOperatorsInput
  _id: FilterRemoveOneAccount_idOperatorsInput
  createdAt: FilterRemoveOneAccountCreatedAtOperatorsInput
}

input FilterRemoveOneAccountAccount_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneAccountNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneAccountNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneAccountCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneAccountInput {
  _ID_ASC
  _ID_DESC
  ACCOUNT_NO_ASC
  ACCOUNT_NO_DESC
  NAME_ASC
  NAME_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyAccountPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyAccountInput {
  account_no: String
  name: String
  initial_balance: Float
  total_Balance: Float
  note: String
  is_default: Boolean
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyAccountOperatorsInput
  OR: [FilterRemoveManyAccountInput!]
  AND: [FilterRemoveManyAccountInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyAccountOperatorsInput {
  account_no: FilterRemoveManyAccountAccount_noOperatorsInput
  name: FilterRemoveManyAccountNameOperatorsInput
  note: FilterRemoveManyAccountNoteOperatorsInput
  _id: FilterRemoveManyAccount_idOperatorsInput
  createdAt: FilterRemoveManyAccountCreatedAtOperatorsInput
}

input FilterRemoveManyAccountAccount_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyAccountNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyAccountNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyAccount_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyAccountCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneAdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneAdjustmentInput {
  reference_no: String!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  warehouse: MongoID!
  product_adjustments: [MongoID]!
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type CreateManyAdjustmentPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Adjustment!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyAdjustmentInput {
  reference_no: String!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  warehouse: MongoID!
  product_adjustments: [MongoID]!
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdAdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOneAdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneAdjustmentOperatorsInput
  OR: [FilterUpdateOneAdjustmentInput!]
  AND: [FilterUpdateOneAdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneAdjustmentOperatorsInput {
  reference_no: FilterUpdateOneAdjustmentReference_noOperatorsInput
  document: FilterUpdateOneAdjustmentDocumentOperatorsInput
  note: FilterUpdateOneAdjustmentNoteOperatorsInput
  _id: FilterUpdateOneAdjustment_idOperatorsInput
  createdAt: FilterUpdateOneAdjustmentCreatedAtOperatorsInput
}

input FilterUpdateOneAdjustmentReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneAdjustmentDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneAdjustmentNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneAdjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneAdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneAdjustmentInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyAdjustmentPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyAdjustmentOperatorsInput
  OR: [FilterUpdateManyAdjustmentInput!]
  AND: [FilterUpdateManyAdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyAdjustmentOperatorsInput {
  reference_no: FilterUpdateManyAdjustmentReference_noOperatorsInput
  document: FilterUpdateManyAdjustmentDocumentOperatorsInput
  note: FilterUpdateManyAdjustmentNoteOperatorsInput
  _id: FilterUpdateManyAdjustment_idOperatorsInput
  createdAt: FilterUpdateManyAdjustmentCreatedAtOperatorsInput
}

input FilterUpdateManyAdjustmentReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyAdjustmentDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyAdjustmentNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyAdjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyAdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyAdjustmentInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdAdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneAdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneAdjustmentOperatorsInput
  OR: [FilterRemoveOneAdjustmentInput!]
  AND: [FilterRemoveOneAdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneAdjustmentOperatorsInput {
  reference_no: FilterRemoveOneAdjustmentReference_noOperatorsInput
  document: FilterRemoveOneAdjustmentDocumentOperatorsInput
  note: FilterRemoveOneAdjustmentNoteOperatorsInput
  _id: FilterRemoveOneAdjustment_idOperatorsInput
  createdAt: FilterRemoveOneAdjustmentCreatedAtOperatorsInput
}

input FilterRemoveOneAdjustmentReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneAdjustmentDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneAdjustmentNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneAdjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneAdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneAdjustmentInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyAdjustmentPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyAdjustmentInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  warehouse: MongoID
  product_adjustments: [MongoID]
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyAdjustmentOperatorsInput
  OR: [FilterRemoveManyAdjustmentInput!]
  AND: [FilterRemoveManyAdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyAdjustmentOperatorsInput {
  reference_no: FilterRemoveManyAdjustmentReference_noOperatorsInput
  document: FilterRemoveManyAdjustmentDocumentOperatorsInput
  note: FilterRemoveManyAdjustmentNoteOperatorsInput
  _id: FilterRemoveManyAdjustment_idOperatorsInput
  createdAt: FilterRemoveManyAdjustmentCreatedAtOperatorsInput
}

input FilterRemoveManyAdjustmentReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyAdjustmentDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyAdjustmentNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyAdjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyAdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneAttributePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Attribute

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneAttributeInput {
  name: String!
  values: [MongoID]!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyAttributePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Attribute!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyAttributeInput {
  name: String!
  values: [MongoID]!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdAttributePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Attribute

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneAttributePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Attribute

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneAttributeOperatorsInput
  OR: [FilterUpdateOneAttributeInput!]
  AND: [FilterUpdateOneAttributeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneAttributeOperatorsInput {
  name: FilterUpdateOneAttributeNameOperatorsInput
  _id: FilterUpdateOneAttribute_idOperatorsInput
  createdAt: FilterUpdateOneAttributeCreatedAtOperatorsInput
}

input FilterUpdateOneAttributeNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneAttribute_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneAttributeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneAttributeInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyAttributePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyAttributeOperatorsInput
  OR: [FilterUpdateManyAttributeInput!]
  AND: [FilterUpdateManyAttributeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyAttributeOperatorsInput {
  name: FilterUpdateManyAttributeNameOperatorsInput
  _id: FilterUpdateManyAttribute_idOperatorsInput
  createdAt: FilterUpdateManyAttributeCreatedAtOperatorsInput
}

input FilterUpdateManyAttributeNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyAttribute_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyAttributeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyAttributeInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdAttributePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Attribute

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneAttributePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Attribute

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneAttributeOperatorsInput
  OR: [FilterRemoveOneAttributeInput!]
  AND: [FilterRemoveOneAttributeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneAttributeOperatorsInput {
  name: FilterRemoveOneAttributeNameOperatorsInput
  _id: FilterRemoveOneAttribute_idOperatorsInput
  createdAt: FilterRemoveOneAttributeCreatedAtOperatorsInput
}

input FilterRemoveOneAttributeNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneAttribute_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneAttributeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneAttributeInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyAttributePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyAttributeInput {
  name: String
  values: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyAttributeOperatorsInput
  OR: [FilterRemoveManyAttributeInput!]
  AND: [FilterRemoveManyAttributeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyAttributeOperatorsInput {
  name: FilterRemoveManyAttributeNameOperatorsInput
  _id: FilterRemoveManyAttribute_idOperatorsInput
  createdAt: FilterRemoveManyAttributeCreatedAtOperatorsInput
}

input FilterRemoveManyAttributeNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyAttribute_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyAttributeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneBrandPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Brand

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneBrandInput {
  name: String!
  image: String
  products: [MongoID]!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyBrandPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Brand!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyBrandInput {
  name: String!
  image: String
  products: [MongoID]!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdBrandPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Brand

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneBrandPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Brand

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneBrandOperatorsInput
  OR: [FilterUpdateOneBrandInput!]
  AND: [FilterUpdateOneBrandInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneBrandOperatorsInput {
  name: FilterUpdateOneBrandNameOperatorsInput
  image: FilterUpdateOneBrandImageOperatorsInput
  _id: FilterUpdateOneBrand_idOperatorsInput
  createdAt: FilterUpdateOneBrandCreatedAtOperatorsInput
}

input FilterUpdateOneBrandNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneBrandImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneBrand_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneBrandCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneBrandInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyBrandPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyBrandOperatorsInput
  OR: [FilterUpdateManyBrandInput!]
  AND: [FilterUpdateManyBrandInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyBrandOperatorsInput {
  name: FilterUpdateManyBrandNameOperatorsInput
  image: FilterUpdateManyBrandImageOperatorsInput
  _id: FilterUpdateManyBrand_idOperatorsInput
  createdAt: FilterUpdateManyBrandCreatedAtOperatorsInput
}

input FilterUpdateManyBrandNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyBrandImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyBrand_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyBrandCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyBrandInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdBrandPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Brand

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneBrandPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Brand

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneBrandOperatorsInput
  OR: [FilterRemoveOneBrandInput!]
  AND: [FilterRemoveOneBrandInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneBrandOperatorsInput {
  name: FilterRemoveOneBrandNameOperatorsInput
  image: FilterRemoveOneBrandImageOperatorsInput
  _id: FilterRemoveOneBrand_idOperatorsInput
  createdAt: FilterRemoveOneBrandCreatedAtOperatorsInput
}

input FilterRemoveOneBrandNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneBrandImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneBrand_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneBrandCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneBrandInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyBrandPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyBrandInput {
  name: String
  image: String
  products: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyBrandOperatorsInput
  OR: [FilterRemoveManyBrandInput!]
  AND: [FilterRemoveManyBrandInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyBrandOperatorsInput {
  name: FilterRemoveManyBrandNameOperatorsInput
  image: FilterRemoveManyBrandImageOperatorsInput
  _id: FilterRemoveManyBrand_idOperatorsInput
  createdAt: FilterRemoveManyBrandCreatedAtOperatorsInput
}

input FilterRemoveManyBrandNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyBrandImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyBrand_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyBrandCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneCategoryPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Category

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneCategoryInput {
  name: String!
  image: String
  variants: [MongoID]!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyCategoryPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Category!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyCategoryInput {
  name: String!
  image: String
  variants: [MongoID]!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdCategoryPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Category

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneCategoryPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Category

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneCategoryOperatorsInput
  OR: [FilterUpdateOneCategoryInput!]
  AND: [FilterUpdateOneCategoryInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneCategoryOperatorsInput {
  name: FilterUpdateOneCategoryNameOperatorsInput
  image: FilterUpdateOneCategoryImageOperatorsInput
  _id: FilterUpdateOneCategory_idOperatorsInput
  createdAt: FilterUpdateOneCategoryCreatedAtOperatorsInput
}

input FilterUpdateOneCategoryNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneCategoryImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneCategory_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneCategoryCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneCategoryInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyCategoryPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyCategoryOperatorsInput
  OR: [FilterUpdateManyCategoryInput!]
  AND: [FilterUpdateManyCategoryInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyCategoryOperatorsInput {
  name: FilterUpdateManyCategoryNameOperatorsInput
  image: FilterUpdateManyCategoryImageOperatorsInput
  _id: FilterUpdateManyCategory_idOperatorsInput
  createdAt: FilterUpdateManyCategoryCreatedAtOperatorsInput
}

input FilterUpdateManyCategoryNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyCategoryImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyCategory_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyCategoryCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyCategoryInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdCategoryPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Category

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneCategoryPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Category

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneCategoryOperatorsInput
  OR: [FilterRemoveOneCategoryInput!]
  AND: [FilterRemoveOneCategoryInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneCategoryOperatorsInput {
  name: FilterRemoveOneCategoryNameOperatorsInput
  image: FilterRemoveOneCategoryImageOperatorsInput
  _id: FilterRemoveOneCategory_idOperatorsInput
  createdAt: FilterRemoveOneCategoryCreatedAtOperatorsInput
}

input FilterRemoveOneCategoryNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneCategoryImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneCategory_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneCategoryCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneCategoryInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyCategoryPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyCategoryInput {
  name: String
  image: String
  variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyCategoryOperatorsInput
  OR: [FilterRemoveManyCategoryInput!]
  AND: [FilterRemoveManyCategoryInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyCategoryOperatorsInput {
  name: FilterRemoveManyCategoryNameOperatorsInput
  image: FilterRemoveManyCategoryImageOperatorsInput
  _id: FilterRemoveManyCategory_idOperatorsInput
  createdAt: FilterRemoveManyCategoryCreatedAtOperatorsInput
}

input FilterRemoveManyCategoryNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyCategoryImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyCategory_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyCategoryCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneCouponPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Coupon

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneCouponInput {
  code: String!
  coupon_type: String!
  amount: Float!
  min_amount: Float!
  user: MongoID
  qty: Float!
  used: Boolean!
  expired_date: Date!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyCouponPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Coupon!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyCouponInput {
  code: String!
  coupon_type: String!
  amount: Float!
  min_amount: Float!
  user: MongoID
  qty: Float!
  used: Boolean!
  expired_date: Date!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdCouponPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Coupon

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneCouponPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Coupon

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneCouponOperatorsInput
  OR: [FilterUpdateOneCouponInput!]
  AND: [FilterUpdateOneCouponInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneCouponOperatorsInput {
  code: FilterUpdateOneCouponCodeOperatorsInput
  _id: FilterUpdateOneCoupon_idOperatorsInput
  createdAt: FilterUpdateOneCouponCreatedAtOperatorsInput
}

input FilterUpdateOneCouponCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneCoupon_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneCouponCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneCouponInput {
  _ID_ASC
  _ID_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyCouponPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyCouponOperatorsInput
  OR: [FilterUpdateManyCouponInput!]
  AND: [FilterUpdateManyCouponInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyCouponOperatorsInput {
  code: FilterUpdateManyCouponCodeOperatorsInput
  _id: FilterUpdateManyCoupon_idOperatorsInput
  createdAt: FilterUpdateManyCouponCreatedAtOperatorsInput
}

input FilterUpdateManyCouponCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyCoupon_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyCouponCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyCouponInput {
  _ID_ASC
  _ID_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdCouponPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Coupon

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneCouponPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Coupon

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneCouponOperatorsInput
  OR: [FilterRemoveOneCouponInput!]
  AND: [FilterRemoveOneCouponInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneCouponOperatorsInput {
  code: FilterRemoveOneCouponCodeOperatorsInput
  _id: FilterRemoveOneCoupon_idOperatorsInput
  createdAt: FilterRemoveOneCouponCreatedAtOperatorsInput
}

input FilterRemoveOneCouponCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneCoupon_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneCouponCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneCouponInput {
  _ID_ASC
  _ID_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyCouponPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyCouponInput {
  code: String
  coupon_type: String
  amount: Float
  min_amount: Float
  user: MongoID
  qty: Float
  used: Boolean
  expired_date: Date
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyCouponOperatorsInput
  OR: [FilterRemoveManyCouponInput!]
  AND: [FilterRemoveManyCouponInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyCouponOperatorsInput {
  code: FilterRemoveManyCouponCodeOperatorsInput
  _id: FilterRemoveManyCoupon_idOperatorsInput
  createdAt: FilterRemoveManyCouponCreatedAtOperatorsInput
}

input FilterRemoveManyCouponCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyCoupon_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyCouponCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneCustomerPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Customer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneCustomerInput {
  customer_group: MongoID!
  company_name: String!
  name: String!
  image: String!
  email: String!
  phone_number: Float!
  gender: String!
  user: MongoID
  address: String!
  city: String!
  country: String!
  tax_no: String
  deposit: Float!
  expense: Float!
  is_active: Boolean!
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

type CreateManyCustomerPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Customer!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyCustomerInput {
  customer_group: MongoID!
  company_name: String!
  name: String!
  image: String!
  email: String!
  phone_number: Float!
  gender: String!
  user: MongoID
  address: String!
  city: String!
  country: String!
  tax_no: String
  deposit: Float!
  expense: Float!
  is_active: Boolean!
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdCustomerPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Customer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneCustomerPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Customer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneCustomerOperatorsInput
  OR: [FilterUpdateOneCustomerInput!]
  AND: [FilterUpdateOneCustomerInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneCustomerOperatorsInput {
  email: FilterUpdateOneCustomerEmailOperatorsInput
  phone_number: FilterUpdateOneCustomerPhone_numberOperatorsInput
  tax_no: FilterUpdateOneCustomerTax_noOperatorsInput
  _id: FilterUpdateOneCustomer_idOperatorsInput
  createdAt: FilterUpdateOneCustomerCreatedAtOperatorsInput
}

input FilterUpdateOneCustomerEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneCustomerPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateOneCustomerTax_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneCustomer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneCustomerCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneCustomerInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  TAX_NO_ASC
  TAX_NO_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyCustomerPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyCustomerOperatorsInput
  OR: [FilterUpdateManyCustomerInput!]
  AND: [FilterUpdateManyCustomerInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyCustomerOperatorsInput {
  email: FilterUpdateManyCustomerEmailOperatorsInput
  phone_number: FilterUpdateManyCustomerPhone_numberOperatorsInput
  tax_no: FilterUpdateManyCustomerTax_noOperatorsInput
  _id: FilterUpdateManyCustomer_idOperatorsInput
  createdAt: FilterUpdateManyCustomerCreatedAtOperatorsInput
}

input FilterUpdateManyCustomerEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyCustomerPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateManyCustomerTax_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyCustomer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyCustomerCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyCustomerInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  TAX_NO_ASC
  TAX_NO_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdCustomerPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Customer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneCustomerPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Customer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneCustomerOperatorsInput
  OR: [FilterRemoveOneCustomerInput!]
  AND: [FilterRemoveOneCustomerInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneCustomerOperatorsInput {
  email: FilterRemoveOneCustomerEmailOperatorsInput
  phone_number: FilterRemoveOneCustomerPhone_numberOperatorsInput
  tax_no: FilterRemoveOneCustomerTax_noOperatorsInput
  _id: FilterRemoveOneCustomer_idOperatorsInput
  createdAt: FilterRemoveOneCustomerCreatedAtOperatorsInput
}

input FilterRemoveOneCustomerEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneCustomerPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveOneCustomerTax_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneCustomer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneCustomerCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneCustomerInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  TAX_NO_ASC
  TAX_NO_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyCustomerPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyCustomerInput {
  customer_group: MongoID
  company_name: String
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  address: String
  city: String
  country: String
  tax_no: String
  deposit: Float
  expense: Float
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyCustomerOperatorsInput
  OR: [FilterRemoveManyCustomerInput!]
  AND: [FilterRemoveManyCustomerInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyCustomerOperatorsInput {
  email: FilterRemoveManyCustomerEmailOperatorsInput
  phone_number: FilterRemoveManyCustomerPhone_numberOperatorsInput
  tax_no: FilterRemoveManyCustomerTax_noOperatorsInput
  _id: FilterRemoveManyCustomer_idOperatorsInput
  createdAt: FilterRemoveManyCustomerCreatedAtOperatorsInput
}

input FilterRemoveManyCustomerEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyCustomerPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveManyCustomerTax_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyCustomer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyCustomerCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneCustomer_GroupPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Customer_Group

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneCustomer_GroupInput {
  name: String!
  percentage: Float!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyCustomer_GroupPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Customer_Group!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyCustomer_GroupInput {
  name: String!
  percentage: Float!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdCustomer_GroupPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Customer_Group

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneCustomer_GroupPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Customer_Group

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneCustomer_GroupOperatorsInput
  OR: [FilterUpdateOneCustomer_GroupInput!]
  AND: [FilterUpdateOneCustomer_GroupInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneCustomer_GroupOperatorsInput {
  name: FilterUpdateOneCustomer_GroupNameOperatorsInput
  _id: FilterUpdateOneCustomer_Group_idOperatorsInput
  createdAt: FilterUpdateOneCustomer_GroupCreatedAtOperatorsInput
}

input FilterUpdateOneCustomer_GroupNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneCustomer_Group_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneCustomer_GroupCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneCustomer_GroupInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyCustomer_GroupPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyCustomer_GroupOperatorsInput
  OR: [FilterUpdateManyCustomer_GroupInput!]
  AND: [FilterUpdateManyCustomer_GroupInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyCustomer_GroupOperatorsInput {
  name: FilterUpdateManyCustomer_GroupNameOperatorsInput
  _id: FilterUpdateManyCustomer_Group_idOperatorsInput
  createdAt: FilterUpdateManyCustomer_GroupCreatedAtOperatorsInput
}

input FilterUpdateManyCustomer_GroupNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyCustomer_Group_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyCustomer_GroupCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyCustomer_GroupInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdCustomer_GroupPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Customer_Group

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneCustomer_GroupPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Customer_Group

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneCustomer_GroupOperatorsInput
  OR: [FilterRemoveOneCustomer_GroupInput!]
  AND: [FilterRemoveOneCustomer_GroupInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneCustomer_GroupOperatorsInput {
  name: FilterRemoveOneCustomer_GroupNameOperatorsInput
  _id: FilterRemoveOneCustomer_Group_idOperatorsInput
  createdAt: FilterRemoveOneCustomer_GroupCreatedAtOperatorsInput
}

input FilterRemoveOneCustomer_GroupNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneCustomer_Group_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneCustomer_GroupCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneCustomer_GroupInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyCustomer_GroupPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyCustomer_GroupInput {
  name: String
  percentage: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyCustomer_GroupOperatorsInput
  OR: [FilterRemoveManyCustomer_GroupInput!]
  AND: [FilterRemoveManyCustomer_GroupInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyCustomer_GroupOperatorsInput {
  name: FilterRemoveManyCustomer_GroupNameOperatorsInput
  _id: FilterRemoveManyCustomer_Group_idOperatorsInput
  createdAt: FilterRemoveManyCustomer_GroupCreatedAtOperatorsInput
}

input FilterRemoveManyCustomer_GroupNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyCustomer_Group_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyCustomer_GroupCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneDepartmentPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Department

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneDepartmentInput {
  name: String!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyDepartmentPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Department!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyDepartmentInput {
  name: String!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdDepartmentPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Department

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdDepartmentInput {
  name: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneDepartmentPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Department

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneDepartmentInput {
  name: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneDepartmentInput {
  name: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneDepartmentOperatorsInput
  OR: [FilterUpdateOneDepartmentInput!]
  AND: [FilterUpdateOneDepartmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneDepartmentOperatorsInput {
  name: FilterUpdateOneDepartmentNameOperatorsInput
  _id: FilterUpdateOneDepartment_idOperatorsInput
  createdAt: FilterUpdateOneDepartmentCreatedAtOperatorsInput
}

input FilterUpdateOneDepartmentNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneDepartment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneDepartmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneDepartmentInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyDepartmentPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyDepartmentInput {
  name: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyDepartmentInput {
  name: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyDepartmentOperatorsInput
  OR: [FilterUpdateManyDepartmentInput!]
  AND: [FilterUpdateManyDepartmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyDepartmentOperatorsInput {
  name: FilterUpdateManyDepartmentNameOperatorsInput
  _id: FilterUpdateManyDepartment_idOperatorsInput
  createdAt: FilterUpdateManyDepartmentCreatedAtOperatorsInput
}

input FilterUpdateManyDepartmentNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyDepartment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyDepartmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyDepartmentInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdDepartmentPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Department

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneDepartmentPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Department

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneDepartmentInput {
  name: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneDepartmentOperatorsInput
  OR: [FilterRemoveOneDepartmentInput!]
  AND: [FilterRemoveOneDepartmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneDepartmentOperatorsInput {
  name: FilterRemoveOneDepartmentNameOperatorsInput
  _id: FilterRemoveOneDepartment_idOperatorsInput
  createdAt: FilterRemoveOneDepartmentCreatedAtOperatorsInput
}

input FilterRemoveOneDepartmentNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneDepartment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneDepartmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneDepartmentInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyDepartmentPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyDepartmentInput {
  name: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyDepartmentOperatorsInput
  OR: [FilterRemoveManyDepartmentInput!]
  AND: [FilterRemoveManyDepartmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyDepartmentOperatorsInput {
  name: FilterRemoveManyDepartmentNameOperatorsInput
  _id: FilterRemoveManyDepartment_idOperatorsInput
  createdAt: FilterRemoveManyDepartmentCreatedAtOperatorsInput
}

input FilterRemoveManyDepartmentNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyDepartment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyDepartmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneEmployeePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Employee

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneEmployeeInput {
  name: String!
  image: String!
  email: String!
  phone_number: Float!
  gender: String!
  user: MongoID
  department: MongoID
  payrolls: [MongoID]!
  address: String!
  city: String!
  country: String!
  is_active: Boolean!
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

type CreateManyEmployeePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Employee!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyEmployeeInput {
  name: String!
  image: String!
  email: String!
  phone_number: Float!
  gender: String!
  user: MongoID
  department: MongoID
  payrolls: [MongoID]!
  address: String!
  city: String!
  country: String!
  is_active: Boolean!
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdEmployeePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Employee

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneEmployeePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Employee

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneEmployeeOperatorsInput
  OR: [FilterUpdateOneEmployeeInput!]
  AND: [FilterUpdateOneEmployeeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneEmployeeOperatorsInput {
  email: FilterUpdateOneEmployeeEmailOperatorsInput
  phone_number: FilterUpdateOneEmployeePhone_numberOperatorsInput
  _id: FilterUpdateOneEmployee_idOperatorsInput
  createdAt: FilterUpdateOneEmployeeCreatedAtOperatorsInput
}

input FilterUpdateOneEmployeeEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneEmployeePhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateOneEmployee_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneEmployeeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneEmployeeInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyEmployeePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyEmployeeOperatorsInput
  OR: [FilterUpdateManyEmployeeInput!]
  AND: [FilterUpdateManyEmployeeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyEmployeeOperatorsInput {
  email: FilterUpdateManyEmployeeEmailOperatorsInput
  phone_number: FilterUpdateManyEmployeePhone_numberOperatorsInput
  _id: FilterUpdateManyEmployee_idOperatorsInput
  createdAt: FilterUpdateManyEmployeeCreatedAtOperatorsInput
}

input FilterUpdateManyEmployeeEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyEmployeePhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateManyEmployee_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyEmployeeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyEmployeeInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdEmployeePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Employee

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneEmployeePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Employee

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneEmployeeOperatorsInput
  OR: [FilterRemoveOneEmployeeInput!]
  AND: [FilterRemoveOneEmployeeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneEmployeeOperatorsInput {
  email: FilterRemoveOneEmployeeEmailOperatorsInput
  phone_number: FilterRemoveOneEmployeePhone_numberOperatorsInput
  _id: FilterRemoveOneEmployee_idOperatorsInput
  createdAt: FilterRemoveOneEmployeeCreatedAtOperatorsInput
}

input FilterRemoveOneEmployeeEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneEmployeePhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveOneEmployee_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneEmployeeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneEmployeeInput {
  _ID_ASC
  _ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyEmployeePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyEmployeeInput {
  name: String
  image: String
  email: String
  phone_number: Float
  gender: String
  user: MongoID
  department: MongoID
  payrolls: [MongoID]
  address: String
  city: String
  country: String
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyEmployeeOperatorsInput
  OR: [FilterRemoveManyEmployeeInput!]
  AND: [FilterRemoveManyEmployeeInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyEmployeeOperatorsInput {
  email: FilterRemoveManyEmployeeEmailOperatorsInput
  phone_number: FilterRemoveManyEmployeePhone_numberOperatorsInput
  _id: FilterRemoveManyEmployee_idOperatorsInput
  createdAt: FilterRemoveManyEmployeeCreatedAtOperatorsInput
}

input FilterRemoveManyEmployeeEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyEmployeePhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveManyEmployee_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyEmployeeCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProduct_AdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product_Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProduct_AdjustmentInput {
  adjustment: MongoID!
  product_variant: MongoID!
  qty: Float!
  action: String!
  updatedAt: Date
  createdAt: Date
}

type CreateManyProduct_AdjustmentPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product_Adjustment!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProduct_AdjustmentInput {
  adjustment: MongoID!
  product_variant: MongoID!
  qty: Float!
  action: String!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProduct_AdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProduct_AdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProduct_AdjustmentOperatorsInput
  OR: [FilterUpdateOneProduct_AdjustmentInput!]
  AND: [FilterUpdateOneProduct_AdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProduct_AdjustmentOperatorsInput {
  adjustment: FilterUpdateOneProduct_AdjustmentAdjustmentOperatorsInput
  _id: FilterUpdateOneProduct_Adjustment_idOperatorsInput
  createdAt: FilterUpdateOneProduct_AdjustmentCreatedAtOperatorsInput
}

input FilterUpdateOneProduct_AdjustmentAdjustmentOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_Adjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_AdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProduct_AdjustmentInput {
  _ID_ASC
  _ID_DESC
  ADJUSTMENT_ASC
  ADJUSTMENT_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProduct_AdjustmentPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProduct_AdjustmentOperatorsInput
  OR: [FilterUpdateManyProduct_AdjustmentInput!]
  AND: [FilterUpdateManyProduct_AdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProduct_AdjustmentOperatorsInput {
  adjustment: FilterUpdateManyProduct_AdjustmentAdjustmentOperatorsInput
  _id: FilterUpdateManyProduct_Adjustment_idOperatorsInput
  createdAt: FilterUpdateManyProduct_AdjustmentCreatedAtOperatorsInput
}

input FilterUpdateManyProduct_AdjustmentAdjustmentOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_Adjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_AdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProduct_AdjustmentInput {
  _ID_ASC
  _ID_DESC
  ADJUSTMENT_ASC
  ADJUSTMENT_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProduct_AdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProduct_AdjustmentPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Adjustment

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProduct_AdjustmentOperatorsInput
  OR: [FilterRemoveOneProduct_AdjustmentInput!]
  AND: [FilterRemoveOneProduct_AdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProduct_AdjustmentOperatorsInput {
  adjustment: FilterRemoveOneProduct_AdjustmentAdjustmentOperatorsInput
  _id: FilterRemoveOneProduct_Adjustment_idOperatorsInput
  createdAt: FilterRemoveOneProduct_AdjustmentCreatedAtOperatorsInput
}

input FilterRemoveOneProduct_AdjustmentAdjustmentOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_Adjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_AdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProduct_AdjustmentInput {
  _ID_ASC
  _ID_DESC
  ADJUSTMENT_ASC
  ADJUSTMENT_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProduct_AdjustmentPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProduct_AdjustmentInput {
  adjustment: MongoID
  product_variant: MongoID
  qty: Float
  action: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProduct_AdjustmentOperatorsInput
  OR: [FilterRemoveManyProduct_AdjustmentInput!]
  AND: [FilterRemoveManyProduct_AdjustmentInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProduct_AdjustmentOperatorsInput {
  adjustment: FilterRemoveManyProduct_AdjustmentAdjustmentOperatorsInput
  _id: FilterRemoveManyProduct_Adjustment_idOperatorsInput
  createdAt: FilterRemoveManyProduct_AdjustmentCreatedAtOperatorsInput
}

input FilterRemoveManyProduct_AdjustmentAdjustmentOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_Adjustment_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_AdjustmentCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProduct_PurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product_Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProduct_PurchaseInput {
  purchase: MongoID!
  product_variant: MongoID!
  unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_cost: Float!
  total: Float!
  status: EnumProduct_PurchaseStatus!
  updatedAt: Date
  createdAt: Date
}

type CreateManyProduct_PurchasePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product_Purchase!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProduct_PurchaseInput {
  purchase: MongoID!
  product_variant: MongoID!
  unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_cost: Float!
  total: Float!
  status: EnumProduct_PurchaseStatus!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProduct_PurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProduct_PurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProduct_PurchaseOperatorsInput
  OR: [FilterUpdateOneProduct_PurchaseInput!]
  AND: [FilterUpdateOneProduct_PurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProduct_PurchaseOperatorsInput {
  _id: FilterUpdateOneProduct_Purchase_idOperatorsInput
  createdAt: FilterUpdateOneProduct_PurchaseCreatedAtOperatorsInput
}

input FilterUpdateOneProduct_Purchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_PurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProduct_PurchaseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProduct_PurchasePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProduct_PurchaseOperatorsInput
  OR: [FilterUpdateManyProduct_PurchaseInput!]
  AND: [FilterUpdateManyProduct_PurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProduct_PurchaseOperatorsInput {
  _id: FilterUpdateManyProduct_Purchase_idOperatorsInput
  createdAt: FilterUpdateManyProduct_PurchaseCreatedAtOperatorsInput
}

input FilterUpdateManyProduct_Purchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_PurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProduct_PurchaseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProduct_PurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProduct_PurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProduct_PurchaseOperatorsInput
  OR: [FilterRemoveOneProduct_PurchaseInput!]
  AND: [FilterRemoveOneProduct_PurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProduct_PurchaseOperatorsInput {
  _id: FilterRemoveOneProduct_Purchase_idOperatorsInput
  createdAt: FilterRemoveOneProduct_PurchaseCreatedAtOperatorsInput
}

input FilterRemoveOneProduct_Purchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_PurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProduct_PurchaseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProduct_PurchasePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProduct_PurchaseInput {
  purchase: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_cost: Float
  total: Float
  status: EnumProduct_PurchaseStatus
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProduct_PurchaseOperatorsInput
  OR: [FilterRemoveManyProduct_PurchaseInput!]
  AND: [FilterRemoveManyProduct_PurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProduct_PurchaseOperatorsInput {
  _id: FilterRemoveManyProduct_Purchase_idOperatorsInput
  createdAt: FilterRemoveManyProduct_PurchaseCreatedAtOperatorsInput
}

input FilterRemoveManyProduct_Purchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_PurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProduct_QuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product_Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProduct_QuotationInput {
  quotation: MongoID!
  product_variant: MongoID!
  unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_price: Float!
  total: Float!
  updatedAt: Date
  createdAt: Date
}

type CreateManyProduct_QuotationPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product_Quotation!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProduct_QuotationInput {
  quotation: MongoID!
  product_variant: MongoID!
  unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_price: Float!
  total: Float!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProduct_QuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProduct_QuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProduct_QuotationOperatorsInput
  OR: [FilterUpdateOneProduct_QuotationInput!]
  AND: [FilterUpdateOneProduct_QuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProduct_QuotationOperatorsInput {
  _id: FilterUpdateOneProduct_Quotation_idOperatorsInput
  createdAt: FilterUpdateOneProduct_QuotationCreatedAtOperatorsInput
}

input FilterUpdateOneProduct_Quotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_QuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProduct_QuotationInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProduct_QuotationPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProduct_QuotationOperatorsInput
  OR: [FilterUpdateManyProduct_QuotationInput!]
  AND: [FilterUpdateManyProduct_QuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProduct_QuotationOperatorsInput {
  _id: FilterUpdateManyProduct_Quotation_idOperatorsInput
  createdAt: FilterUpdateManyProduct_QuotationCreatedAtOperatorsInput
}

input FilterUpdateManyProduct_Quotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_QuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProduct_QuotationInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProduct_QuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProduct_QuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProduct_QuotationOperatorsInput
  OR: [FilterRemoveOneProduct_QuotationInput!]
  AND: [FilterRemoveOneProduct_QuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProduct_QuotationOperatorsInput {
  _id: FilterRemoveOneProduct_Quotation_idOperatorsInput
  createdAt: FilterRemoveOneProduct_QuotationCreatedAtOperatorsInput
}

input FilterRemoveOneProduct_Quotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_QuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProduct_QuotationInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProduct_QuotationPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProduct_QuotationInput {
  quotation: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProduct_QuotationOperatorsInput
  OR: [FilterRemoveManyProduct_QuotationInput!]
  AND: [FilterRemoveManyProduct_QuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProduct_QuotationOperatorsInput {
  _id: FilterRemoveManyProduct_Quotation_idOperatorsInput
  createdAt: FilterRemoveManyProduct_QuotationCreatedAtOperatorsInput
}

input FilterRemoveManyProduct_Quotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_QuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProduct_ReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product_Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProduct_ReturnInput {
  return: MongoID!
  product_variant: MongoID!
  unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_price: Float!
  total: Float!
  updatedAt: Date
  createdAt: Date
}

type CreateManyProduct_ReturnPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product_Return!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProduct_ReturnInput {
  return: MongoID!
  product_variant: MongoID!
  unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_price: Float!
  total: Float!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProduct_ReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProduct_ReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProduct_ReturnOperatorsInput
  OR: [FilterUpdateOneProduct_ReturnInput!]
  AND: [FilterUpdateOneProduct_ReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProduct_ReturnOperatorsInput {
  _id: FilterUpdateOneProduct_Return_idOperatorsInput
  createdAt: FilterUpdateOneProduct_ReturnCreatedAtOperatorsInput
}

input FilterUpdateOneProduct_Return_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_ReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProduct_ReturnInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProduct_ReturnPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProduct_ReturnOperatorsInput
  OR: [FilterUpdateManyProduct_ReturnInput!]
  AND: [FilterUpdateManyProduct_ReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProduct_ReturnOperatorsInput {
  _id: FilterUpdateManyProduct_Return_idOperatorsInput
  createdAt: FilterUpdateManyProduct_ReturnCreatedAtOperatorsInput
}

input FilterUpdateManyProduct_Return_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_ReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProduct_ReturnInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProduct_ReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProduct_ReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProduct_ReturnOperatorsInput
  OR: [FilterRemoveOneProduct_ReturnInput!]
  AND: [FilterRemoveOneProduct_ReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProduct_ReturnOperatorsInput {
  _id: FilterRemoveOneProduct_Return_idOperatorsInput
  createdAt: FilterRemoveOneProduct_ReturnCreatedAtOperatorsInput
}

input FilterRemoveOneProduct_Return_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_ReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProduct_ReturnInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProduct_ReturnPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProduct_ReturnInput {
  return: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProduct_ReturnOperatorsInput
  OR: [FilterRemoveManyProduct_ReturnInput!]
  AND: [FilterRemoveManyProduct_ReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProduct_ReturnOperatorsInput {
  _id: FilterRemoveManyProduct_Return_idOperatorsInput
  createdAt: FilterRemoveManyProduct_ReturnCreatedAtOperatorsInput
}

input FilterRemoveManyProduct_Return_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_ReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProduct_SalePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product_Sale

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProduct_SaleInput {
  sale: MongoID!
  product_variant: MongoID!
  unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_price: Float!
  total: Float!
  updatedAt: Date
  createdAt: Date
}

type CreateManyProduct_SalePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product_Sale!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProduct_SaleInput {
  sale: MongoID!
  product_variant: MongoID!
  unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  discount: Float!
  net_unit_price: Float!
  total: Float!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProduct_SalePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Sale

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProduct_SalePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Sale

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProduct_SaleOperatorsInput
  OR: [FilterUpdateOneProduct_SaleInput!]
  AND: [FilterUpdateOneProduct_SaleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProduct_SaleOperatorsInput {
  _id: FilterUpdateOneProduct_Sale_idOperatorsInput
  createdAt: FilterUpdateOneProduct_SaleCreatedAtOperatorsInput
}

input FilterUpdateOneProduct_Sale_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_SaleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProduct_SaleInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProduct_SalePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProduct_SaleOperatorsInput
  OR: [FilterUpdateManyProduct_SaleInput!]
  AND: [FilterUpdateManyProduct_SaleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProduct_SaleOperatorsInput {
  _id: FilterUpdateManyProduct_Sale_idOperatorsInput
  createdAt: FilterUpdateManyProduct_SaleCreatedAtOperatorsInput
}

input FilterUpdateManyProduct_Sale_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_SaleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProduct_SaleInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProduct_SalePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Sale

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProduct_SalePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Sale

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProduct_SaleOperatorsInput
  OR: [FilterRemoveOneProduct_SaleInput!]
  AND: [FilterRemoveOneProduct_SaleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProduct_SaleOperatorsInput {
  _id: FilterRemoveOneProduct_Sale_idOperatorsInput
  createdAt: FilterRemoveOneProduct_SaleCreatedAtOperatorsInput
}

input FilterRemoveOneProduct_Sale_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_SaleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProduct_SaleInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProduct_SalePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProduct_SaleInput {
  sale: MongoID
  product_variant: MongoID
  unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  discount: Float
  net_unit_price: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProduct_SaleOperatorsInput
  OR: [FilterRemoveManyProduct_SaleInput!]
  AND: [FilterRemoveManyProduct_SaleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProduct_SaleOperatorsInput {
  _id: FilterRemoveManyProduct_Sale_idOperatorsInput
  createdAt: FilterRemoveManyProduct_SaleCreatedAtOperatorsInput
}

input FilterRemoveManyProduct_Sale_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_SaleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProduct_SupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product_Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProduct_SupplierInput {
  productVariant: MongoID!
  supplier: MongoID!
  qty: Float!
  price: Float!
  itemCode: String!
  updatedAt: Date
  createdAt: Date
}

type CreateManyProduct_SupplierPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product_Supplier!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProduct_SupplierInput {
  productVariant: MongoID!
  supplier: MongoID!
  qty: Float!
  price: Float!
  itemCode: String!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProduct_SupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProduct_SupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProduct_SupplierOperatorsInput
  OR: [FilterUpdateOneProduct_SupplierInput!]
  AND: [FilterUpdateOneProduct_SupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProduct_SupplierOperatorsInput {
  itemCode: FilterUpdateOneProduct_SupplierItemCodeOperatorsInput
  _id: FilterUpdateOneProduct_Supplier_idOperatorsInput
  createdAt: FilterUpdateOneProduct_SupplierCreatedAtOperatorsInput
}

input FilterUpdateOneProduct_SupplierItemCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneProduct_Supplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_SupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProduct_SupplierInput {
  _ID_ASC
  _ID_DESC
  ITEMCODE_ASC
  ITEMCODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProduct_SupplierPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProduct_SupplierOperatorsInput
  OR: [FilterUpdateManyProduct_SupplierInput!]
  AND: [FilterUpdateManyProduct_SupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProduct_SupplierOperatorsInput {
  itemCode: FilterUpdateManyProduct_SupplierItemCodeOperatorsInput
  _id: FilterUpdateManyProduct_Supplier_idOperatorsInput
  createdAt: FilterUpdateManyProduct_SupplierCreatedAtOperatorsInput
}

input FilterUpdateManyProduct_SupplierItemCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyProduct_Supplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_SupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProduct_SupplierInput {
  _ID_ASC
  _ID_DESC
  ITEMCODE_ASC
  ITEMCODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProduct_SupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProduct_SupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProduct_SupplierOperatorsInput
  OR: [FilterRemoveOneProduct_SupplierInput!]
  AND: [FilterRemoveOneProduct_SupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProduct_SupplierOperatorsInput {
  itemCode: FilterRemoveOneProduct_SupplierItemCodeOperatorsInput
  _id: FilterRemoveOneProduct_Supplier_idOperatorsInput
  createdAt: FilterRemoveOneProduct_SupplierCreatedAtOperatorsInput
}

input FilterRemoveOneProduct_SupplierItemCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneProduct_Supplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_SupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProduct_SupplierInput {
  _ID_ASC
  _ID_DESC
  ITEMCODE_ASC
  ITEMCODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProduct_SupplierPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProduct_SupplierInput {
  productVariant: MongoID
  supplier: MongoID
  qty: Float
  price: Float
  itemCode: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProduct_SupplierOperatorsInput
  OR: [FilterRemoveManyProduct_SupplierInput!]
  AND: [FilterRemoveManyProduct_SupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProduct_SupplierOperatorsInput {
  itemCode: FilterRemoveManyProduct_SupplierItemCodeOperatorsInput
  _id: FilterRemoveManyProduct_Supplier_idOperatorsInput
  createdAt: FilterRemoveManyProduct_SupplierCreatedAtOperatorsInput
}

input FilterRemoveManyProduct_SupplierItemCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyProduct_Supplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_SupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProduct_TransferPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product_Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProduct_TransferInput {
  transfer: MongoID!
  product_variant: MongoID!
  purchase_unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  net_unit_cost: Float!
  total: Float!
  updatedAt: Date
  createdAt: Date
}

type CreateManyProduct_TransferPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product_Transfer!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProduct_TransferInput {
  transfer: MongoID!
  product_variant: MongoID!
  purchase_unit: MongoID!
  qty: Float!
  tax_rate: Float!
  tax: Float!
  net_unit_cost: Float!
  total: Float!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProduct_TransferPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProduct_TransferPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProduct_TransferOperatorsInput
  OR: [FilterUpdateOneProduct_TransferInput!]
  AND: [FilterUpdateOneProduct_TransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProduct_TransferOperatorsInput {
  _id: FilterUpdateOneProduct_Transfer_idOperatorsInput
  createdAt: FilterUpdateOneProduct_TransferCreatedAtOperatorsInput
}

input FilterUpdateOneProduct_Transfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_TransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProduct_TransferInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProduct_TransferPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProduct_TransferOperatorsInput
  OR: [FilterUpdateManyProduct_TransferInput!]
  AND: [FilterUpdateManyProduct_TransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProduct_TransferOperatorsInput {
  _id: FilterUpdateManyProduct_Transfer_idOperatorsInput
  createdAt: FilterUpdateManyProduct_TransferCreatedAtOperatorsInput
}

input FilterUpdateManyProduct_Transfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_TransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProduct_TransferInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProduct_TransferPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProduct_TransferPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProduct_TransferOperatorsInput
  OR: [FilterRemoveOneProduct_TransferInput!]
  AND: [FilterRemoveOneProduct_TransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProduct_TransferOperatorsInput {
  _id: FilterRemoveOneProduct_Transfer_idOperatorsInput
  createdAt: FilterRemoveOneProduct_TransferCreatedAtOperatorsInput
}

input FilterRemoveOneProduct_Transfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_TransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProduct_TransferInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProduct_TransferPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProduct_TransferInput {
  transfer: MongoID
  product_variant: MongoID
  purchase_unit: MongoID
  qty: Float
  tax_rate: Float
  tax: Float
  net_unit_cost: Float
  total: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProduct_TransferOperatorsInput
  OR: [FilterRemoveManyProduct_TransferInput!]
  AND: [FilterRemoveManyProduct_TransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProduct_TransferOperatorsInput {
  _id: FilterRemoveManyProduct_Transfer_idOperatorsInput
  createdAt: FilterRemoveManyProduct_TransferCreatedAtOperatorsInput
}

input FilterRemoveManyProduct_Transfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_TransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProduct_VariantPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product_Variant

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProduct_VariantInput {
  variant: MongoID!
  product: MongoID!
  unit: MongoID!
  category: MongoID!
  tax: MongoID
  purchase_unit: MongoID!
  sale_unit: MongoID!
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type!
  barcode_symbology: String!
  item_code: String!
  qty: Float!
  position: Float!
  additional_price: Float!
  alert_qty: Float
  promotion: Boolean!
  promotion_price: Float!
  price: Float!
  cost: Float!
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean!
  product_list: String
  qty_list: String
  price_list: String
  updatedAt: Date
  createdAt: Date
}

type CreateManyProduct_VariantPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product_Variant!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProduct_VariantInput {
  variant: MongoID!
  product: MongoID!
  unit: MongoID!
  category: MongoID!
  tax: MongoID
  purchase_unit: MongoID!
  sale_unit: MongoID!
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type!
  barcode_symbology: String!
  item_code: String!
  qty: Float!
  position: Float!
  additional_price: Float!
  alert_qty: Float
  promotion: Boolean!
  promotion_price: Float!
  price: Float!
  cost: Float!
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean!
  product_list: String
  qty_list: String
  price_list: String
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProduct_VariantPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Variant

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProduct_VariantPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Variant

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProduct_VariantOperatorsInput
  OR: [FilterUpdateOneProduct_VariantInput!]
  AND: [FilterUpdateOneProduct_VariantInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProduct_VariantOperatorsInput {
  variant: FilterUpdateOneProduct_VariantVariantOperatorsInput
  item_code: FilterUpdateOneProduct_VariantItem_codeOperatorsInput
  _id: FilterUpdateOneProduct_Variant_idOperatorsInput
  createdAt: FilterUpdateOneProduct_VariantCreatedAtOperatorsInput
}

input FilterUpdateOneProduct_VariantVariantOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_VariantItem_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneProduct_Variant_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_VariantCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProduct_VariantInput {
  _ID_ASC
  _ID_DESC
  VARIANT_ASC
  VARIANT_DESC
  ITEM_CODE_ASC
  ITEM_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProduct_VariantPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProduct_VariantOperatorsInput
  OR: [FilterUpdateManyProduct_VariantInput!]
  AND: [FilterUpdateManyProduct_VariantInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProduct_VariantOperatorsInput {
  variant: FilterUpdateManyProduct_VariantVariantOperatorsInput
  item_code: FilterUpdateManyProduct_VariantItem_codeOperatorsInput
  _id: FilterUpdateManyProduct_Variant_idOperatorsInput
  createdAt: FilterUpdateManyProduct_VariantCreatedAtOperatorsInput
}

input FilterUpdateManyProduct_VariantVariantOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_VariantItem_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyProduct_Variant_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_VariantCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProduct_VariantInput {
  _ID_ASC
  _ID_DESC
  VARIANT_ASC
  VARIANT_DESC
  ITEM_CODE_ASC
  ITEM_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProduct_VariantPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Variant

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProduct_VariantPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Variant

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProduct_VariantOperatorsInput
  OR: [FilterRemoveOneProduct_VariantInput!]
  AND: [FilterRemoveOneProduct_VariantInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProduct_VariantOperatorsInput {
  variant: FilterRemoveOneProduct_VariantVariantOperatorsInput
  item_code: FilterRemoveOneProduct_VariantItem_codeOperatorsInput
  _id: FilterRemoveOneProduct_Variant_idOperatorsInput
  createdAt: FilterRemoveOneProduct_VariantCreatedAtOperatorsInput
}

input FilterRemoveOneProduct_VariantVariantOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_VariantItem_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneProduct_Variant_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_VariantCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProduct_VariantInput {
  _ID_ASC
  _ID_DESC
  VARIANT_ASC
  VARIANT_DESC
  ITEM_CODE_ASC
  ITEM_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProduct_VariantPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProduct_VariantInput {
  variant: MongoID
  product: MongoID
  unit: MongoID
  category: MongoID
  tax: MongoID
  purchase_unit: MongoID
  sale_unit: MongoID
  productSuppliers: [MongoID]
  product_type: EnumProduct_VariantProduct_type
  barcode_symbology: String
  item_code: String
  qty: Float
  position: Float
  additional_price: Float
  alert_qty: Float
  promotion: Boolean
  promotion_price: Float
  price: Float
  cost: Float
  tax_method: EnumProduct_VariantTax_method
  starting_date: Date
  last_date: Date
  image: String
  featured: Boolean
  product_list: String
  qty_list: String
  price_list: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProduct_VariantOperatorsInput
  OR: [FilterRemoveManyProduct_VariantInput!]
  AND: [FilterRemoveManyProduct_VariantInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProduct_VariantOperatorsInput {
  variant: FilterRemoveManyProduct_VariantVariantOperatorsInput
  item_code: FilterRemoveManyProduct_VariantItem_codeOperatorsInput
  _id: FilterRemoveManyProduct_Variant_idOperatorsInput
  createdAt: FilterRemoveManyProduct_VariantCreatedAtOperatorsInput
}

input FilterRemoveManyProduct_VariantVariantOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_VariantItem_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyProduct_Variant_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_VariantCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProduct_WarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product_Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProduct_WarehouseInput {
  product_variant: MongoID!
  warehouse: MongoID!
  qty: Float!
  updatedAt: Date
  createdAt: Date
}

type CreateManyProduct_WarehousePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product_Warehouse!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProduct_WarehouseInput {
  product_variant: MongoID!
  warehouse: MongoID!
  qty: Float!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProduct_WarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProduct_WarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product_Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProduct_WarehouseOperatorsInput
  OR: [FilterUpdateOneProduct_WarehouseInput!]
  AND: [FilterUpdateOneProduct_WarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProduct_WarehouseOperatorsInput {
  _id: FilterUpdateOneProduct_Warehouse_idOperatorsInput
  createdAt: FilterUpdateOneProduct_WarehouseCreatedAtOperatorsInput
}

input FilterUpdateOneProduct_Warehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProduct_WarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProduct_WarehouseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProduct_WarehousePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProduct_WarehouseOperatorsInput
  OR: [FilterUpdateManyProduct_WarehouseInput!]
  AND: [FilterUpdateManyProduct_WarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProduct_WarehouseOperatorsInput {
  _id: FilterUpdateManyProduct_Warehouse_idOperatorsInput
  createdAt: FilterUpdateManyProduct_WarehouseCreatedAtOperatorsInput
}

input FilterUpdateManyProduct_Warehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProduct_WarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProduct_WarehouseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProduct_WarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProduct_WarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product_Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProduct_WarehouseOperatorsInput
  OR: [FilterRemoveOneProduct_WarehouseInput!]
  AND: [FilterRemoveOneProduct_WarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProduct_WarehouseOperatorsInput {
  _id: FilterRemoveOneProduct_Warehouse_idOperatorsInput
  createdAt: FilterRemoveOneProduct_WarehouseCreatedAtOperatorsInput
}

input FilterRemoveOneProduct_Warehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProduct_WarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProduct_WarehouseInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProduct_WarehousePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProduct_WarehouseInput {
  product_variant: MongoID
  warehouse: MongoID
  qty: Float
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProduct_WarehouseOperatorsInput
  OR: [FilterRemoveManyProduct_WarehouseInput!]
  AND: [FilterRemoveManyProduct_WarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProduct_WarehouseOperatorsInput {
  _id: FilterRemoveManyProduct_Warehouse_idOperatorsInput
  createdAt: FilterRemoveManyProduct_WarehouseCreatedAtOperatorsInput
}

input FilterRemoveManyProduct_Warehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProduct_WarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneProductPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Product

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneProductInput {
  name: String!
  code: String!
  brand: MongoID!
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyProductPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Product!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyProductInput {
  name: String!
  code: String!
  brand: MongoID!
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdProductPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneProductPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Product

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneProductOperatorsInput
  OR: [FilterUpdateOneProductInput!]
  AND: [FilterUpdateOneProductInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneProductOperatorsInput {
  name: FilterUpdateOneProductNameOperatorsInput
  code: FilterUpdateOneProductCodeOperatorsInput
  _id: FilterUpdateOneProduct_idOperatorsInput
  createdAt: FilterUpdateOneProductCreatedAtOperatorsInput
}

input FilterUpdateOneProductNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneProductCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneProduct_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneProductCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneProductInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyProductPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyProductOperatorsInput
  OR: [FilterUpdateManyProductInput!]
  AND: [FilterUpdateManyProductInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyProductOperatorsInput {
  name: FilterUpdateManyProductNameOperatorsInput
  code: FilterUpdateManyProductCodeOperatorsInput
  _id: FilterUpdateManyProduct_idOperatorsInput
  createdAt: FilterUpdateManyProductCreatedAtOperatorsInput
}

input FilterUpdateManyProductNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyProductCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyProduct_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyProductCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyProductInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdProductPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneProductPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Product

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneProductOperatorsInput
  OR: [FilterRemoveOneProductInput!]
  AND: [FilterRemoveOneProductInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneProductOperatorsInput {
  name: FilterRemoveOneProductNameOperatorsInput
  code: FilterRemoveOneProductCodeOperatorsInput
  _id: FilterRemoveOneProduct_idOperatorsInput
  createdAt: FilterRemoveOneProductCreatedAtOperatorsInput
}

input FilterRemoveOneProductNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneProductCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneProduct_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneProductCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneProductInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CODE_ASC
  CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyProductPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyProductInput {
  name: String
  code: String
  brand: MongoID
  product_variants: [MongoID]
  file: String
  product_details: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyProductOperatorsInput
  OR: [FilterRemoveManyProductInput!]
  AND: [FilterRemoveManyProductInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyProductOperatorsInput {
  name: FilterRemoveManyProductNameOperatorsInput
  code: FilterRemoveManyProductCodeOperatorsInput
  _id: FilterRemoveManyProduct_idOperatorsInput
  createdAt: FilterRemoveManyProductCreatedAtOperatorsInput
}

input FilterRemoveManyProductNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyProductCodeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyProduct_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyProductCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOnePurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOnePurchaseInput {
  reference_no: String!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_cost: Float!
  order_tax_rate: Float!
  order_tax: Float!
  order_discount: Float!
  shipping_cost: Float!
  grandtotal: Float!
  paid_amount: Float!
  user: MongoID!
  warehouse: MongoID!
  supplier: MongoID!
  product_purchases: [MongoID]!
  product_purchase_returns: [MongoID]!
  status: EnumPurchaseStatus!
  payment_status: EnumPurchasePayment_status!
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type CreateManyPurchasePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Purchase!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyPurchaseInput {
  reference_no: String!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_cost: Float!
  order_tax_rate: Float!
  order_tax: Float!
  order_discount: Float!
  shipping_cost: Float!
  grandtotal: Float!
  paid_amount: Float!
  user: MongoID!
  warehouse: MongoID!
  supplier: MongoID!
  product_purchases: [MongoID]!
  product_purchase_returns: [MongoID]!
  status: EnumPurchaseStatus!
  payment_status: EnumPurchasePayment_status!
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdPurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdPurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOnePurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOnePurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOnePurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOnePurchaseOperatorsInput
  OR: [FilterUpdateOnePurchaseInput!]
  AND: [FilterUpdateOnePurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOnePurchaseOperatorsInput {
  reference_no: FilterUpdateOnePurchaseReference_noOperatorsInput
  document: FilterUpdateOnePurchaseDocumentOperatorsInput
  note: FilterUpdateOnePurchaseNoteOperatorsInput
  _id: FilterUpdateOnePurchase_idOperatorsInput
  createdAt: FilterUpdateOnePurchaseCreatedAtOperatorsInput
}

input FilterUpdateOnePurchaseReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOnePurchaseDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOnePurchaseNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOnePurchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOnePurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOnePurchaseInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyPurchasePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyPurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyPurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyPurchaseOperatorsInput
  OR: [FilterUpdateManyPurchaseInput!]
  AND: [FilterUpdateManyPurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyPurchaseOperatorsInput {
  reference_no: FilterUpdateManyPurchaseReference_noOperatorsInput
  document: FilterUpdateManyPurchaseDocumentOperatorsInput
  note: FilterUpdateManyPurchaseNoteOperatorsInput
  _id: FilterUpdateManyPurchase_idOperatorsInput
  createdAt: FilterUpdateManyPurchaseCreatedAtOperatorsInput
}

input FilterUpdateManyPurchaseReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyPurchaseDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyPurchaseNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyPurchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyPurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyPurchaseInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdPurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOnePurchasePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Purchase

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOnePurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOnePurchaseOperatorsInput
  OR: [FilterRemoveOnePurchaseInput!]
  AND: [FilterRemoveOnePurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOnePurchaseOperatorsInput {
  reference_no: FilterRemoveOnePurchaseReference_noOperatorsInput
  document: FilterRemoveOnePurchaseDocumentOperatorsInput
  note: FilterRemoveOnePurchaseNoteOperatorsInput
  _id: FilterRemoveOnePurchase_idOperatorsInput
  createdAt: FilterRemoveOnePurchaseCreatedAtOperatorsInput
}

input FilterRemoveOnePurchaseReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOnePurchaseDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOnePurchaseNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOnePurchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOnePurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOnePurchaseInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyPurchasePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyPurchaseInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_cost: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  user: MongoID
  warehouse: MongoID
  supplier: MongoID
  product_purchases: [MongoID]
  product_purchase_returns: [MongoID]
  status: EnumPurchaseStatus
  payment_status: EnumPurchasePayment_status
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyPurchaseOperatorsInput
  OR: [FilterRemoveManyPurchaseInput!]
  AND: [FilterRemoveManyPurchaseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyPurchaseOperatorsInput {
  reference_no: FilterRemoveManyPurchaseReference_noOperatorsInput
  document: FilterRemoveManyPurchaseDocumentOperatorsInput
  note: FilterRemoveManyPurchaseNoteOperatorsInput
  _id: FilterRemoveManyPurchase_idOperatorsInput
  createdAt: FilterRemoveManyPurchaseCreatedAtOperatorsInput
}

input FilterRemoveManyPurchaseReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyPurchaseDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyPurchaseNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyPurchase_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyPurchaseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneReturnInput {
  reference_no: String!
  user: MongoID!
  biller: MongoID!
  warehouse: MongoID!
  account: MongoID!
  customer: MongoID!
  product_returns: MongoID!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_price: Float!
  order_tax_rate: Float!
  order_tax: Float!
  grandtotal: Float!
  document: String
  return_note: String
  staff_note: String
  updatedAt: Date
  createdAt: Date
}

type CreateManyReturnPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Return!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyReturnInput {
  reference_no: String!
  user: MongoID!
  biller: MongoID!
  warehouse: MongoID!
  account: MongoID!
  customer: MongoID!
  product_returns: MongoID!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_price: Float!
  order_tax_rate: Float!
  order_tax: Float!
  grandtotal: Float!
  document: String
  return_note: String
  staff_note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOneReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneReturnOperatorsInput
  OR: [FilterUpdateOneReturnInput!]
  AND: [FilterUpdateOneReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneReturnOperatorsInput {
  reference_no: FilterUpdateOneReturnReference_noOperatorsInput
  document: FilterUpdateOneReturnDocumentOperatorsInput
  return_note: FilterUpdateOneReturnReturn_noteOperatorsInput
  staff_note: FilterUpdateOneReturnStaff_noteOperatorsInput
  _id: FilterUpdateOneReturn_idOperatorsInput
  createdAt: FilterUpdateOneReturnCreatedAtOperatorsInput
}

input FilterUpdateOneReturnReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneReturnDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneReturnReturn_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneReturnStaff_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneReturn_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneReturnInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  RETURN_NOTE_ASC
  RETURN_NOTE_DESC
  STAFF_NOTE_ASC
  STAFF_NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyReturnPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyReturnOperatorsInput
  OR: [FilterUpdateManyReturnInput!]
  AND: [FilterUpdateManyReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyReturnOperatorsInput {
  reference_no: FilterUpdateManyReturnReference_noOperatorsInput
  document: FilterUpdateManyReturnDocumentOperatorsInput
  return_note: FilterUpdateManyReturnReturn_noteOperatorsInput
  staff_note: FilterUpdateManyReturnStaff_noteOperatorsInput
  _id: FilterUpdateManyReturn_idOperatorsInput
  createdAt: FilterUpdateManyReturnCreatedAtOperatorsInput
}

input FilterUpdateManyReturnReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyReturnDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyReturnReturn_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyReturnStaff_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyReturn_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyReturnInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  RETURN_NOTE_ASC
  RETURN_NOTE_DESC
  STAFF_NOTE_ASC
  STAFF_NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneReturnPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Return

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneReturnOperatorsInput
  OR: [FilterRemoveOneReturnInput!]
  AND: [FilterRemoveOneReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneReturnOperatorsInput {
  reference_no: FilterRemoveOneReturnReference_noOperatorsInput
  document: FilterRemoveOneReturnDocumentOperatorsInput
  return_note: FilterRemoveOneReturnReturn_noteOperatorsInput
  staff_note: FilterRemoveOneReturnStaff_noteOperatorsInput
  _id: FilterRemoveOneReturn_idOperatorsInput
  createdAt: FilterRemoveOneReturnCreatedAtOperatorsInput
}

input FilterRemoveOneReturnReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneReturnDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneReturnReturn_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneReturnStaff_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneReturn_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneReturnInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  RETURN_NOTE_ASC
  RETURN_NOTE_DESC
  STAFF_NOTE_ASC
  STAFF_NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyReturnPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyReturnInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  account: MongoID
  customer: MongoID
  product_returns: MongoID
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  grandtotal: Float
  document: String
  return_note: String
  staff_note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyReturnOperatorsInput
  OR: [FilterRemoveManyReturnInput!]
  AND: [FilterRemoveManyReturnInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyReturnOperatorsInput {
  reference_no: FilterRemoveManyReturnReference_noOperatorsInput
  document: FilterRemoveManyReturnDocumentOperatorsInput
  return_note: FilterRemoveManyReturnReturn_noteOperatorsInput
  staff_note: FilterRemoveManyReturnStaff_noteOperatorsInput
  _id: FilterRemoveManyReturn_idOperatorsInput
  createdAt: FilterRemoveManyReturnCreatedAtOperatorsInput
}

input FilterRemoveManyReturnReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyReturnDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyReturnReturn_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyReturnStaff_noteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyReturn_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyReturnCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneQuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneQuotationInput {
  reference_no: String!
  user: MongoID!
  biller: MongoID!
  warehouse: MongoID!
  supplier: MongoID!
  customer: MongoID!
  product_quotations: [MongoID]!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_price: Float!
  order_tax_rate: Float!
  order_tax: Float!
  order_discount: Float!
  shipping_cost: Float!
  grandtotal: Float!
  paid_amount: Float!
  status: EnumQuotationStatus!
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type CreateManyQuotationPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Quotation!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyQuotationInput {
  reference_no: String!
  user: MongoID!
  biller: MongoID!
  warehouse: MongoID!
  supplier: MongoID!
  customer: MongoID!
  product_quotations: [MongoID]!
  item: Float!
  total_qty: Float!
  total_discount: Float!
  total_tax: Float!
  total_price: Float!
  order_tax_rate: Float!
  order_tax: Float!
  order_discount: Float!
  shipping_cost: Float!
  grandtotal: Float!
  paid_amount: Float!
  status: EnumQuotationStatus!
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdQuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOneQuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneQuotationOperatorsInput
  OR: [FilterUpdateOneQuotationInput!]
  AND: [FilterUpdateOneQuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneQuotationOperatorsInput {
  reference_no: FilterUpdateOneQuotationReference_noOperatorsInput
  document: FilterUpdateOneQuotationDocumentOperatorsInput
  note: FilterUpdateOneQuotationNoteOperatorsInput
  _id: FilterUpdateOneQuotation_idOperatorsInput
  createdAt: FilterUpdateOneQuotationCreatedAtOperatorsInput
}

input FilterUpdateOneQuotationReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneQuotationDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneQuotationNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneQuotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneQuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneQuotationInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyQuotationPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyQuotationOperatorsInput
  OR: [FilterUpdateManyQuotationInput!]
  AND: [FilterUpdateManyQuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyQuotationOperatorsInput {
  reference_no: FilterUpdateManyQuotationReference_noOperatorsInput
  document: FilterUpdateManyQuotationDocumentOperatorsInput
  note: FilterUpdateManyQuotationNoteOperatorsInput
  _id: FilterUpdateManyQuotation_idOperatorsInput
  createdAt: FilterUpdateManyQuotationCreatedAtOperatorsInput
}

input FilterUpdateManyQuotationReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyQuotationDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyQuotationNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyQuotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyQuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyQuotationInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdQuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneQuotationPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Quotation

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneQuotationOperatorsInput
  OR: [FilterRemoveOneQuotationInput!]
  AND: [FilterRemoveOneQuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneQuotationOperatorsInput {
  reference_no: FilterRemoveOneQuotationReference_noOperatorsInput
  document: FilterRemoveOneQuotationDocumentOperatorsInput
  note: FilterRemoveOneQuotationNoteOperatorsInput
  _id: FilterRemoveOneQuotation_idOperatorsInput
  createdAt: FilterRemoveOneQuotationCreatedAtOperatorsInput
}

input FilterRemoveOneQuotationReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneQuotationDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneQuotationNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneQuotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneQuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneQuotationInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyQuotationPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyQuotationInput {
  reference_no: String
  user: MongoID
  biller: MongoID
  warehouse: MongoID
  supplier: MongoID
  customer: MongoID
  product_quotations: [MongoID]
  item: Float
  total_qty: Float
  total_discount: Float
  total_tax: Float
  total_price: Float
  order_tax_rate: Float
  order_tax: Float
  order_discount: Float
  shipping_cost: Float
  grandtotal: Float
  paid_amount: Float
  status: EnumQuotationStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyQuotationOperatorsInput
  OR: [FilterRemoveManyQuotationInput!]
  AND: [FilterRemoveManyQuotationInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyQuotationOperatorsInput {
  reference_no: FilterRemoveManyQuotationReference_noOperatorsInput
  document: FilterRemoveManyQuotationDocumentOperatorsInput
  note: FilterRemoveManyQuotationNoteOperatorsInput
  _id: FilterRemoveManyQuotation_idOperatorsInput
  createdAt: FilterRemoveManyQuotationCreatedAtOperatorsInput
}

input FilterRemoveManyQuotationReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyQuotationDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyQuotationNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyQuotation_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyQuotationCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneRolePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Role

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneRoleInput {
  name: String!
  description: String!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyRolePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Role!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyRoleInput {
  name: String!
  description: String!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdRolePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Role

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdRoleInput {
  name: String
  description: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneRolePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Role

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneRoleInput {
  name: String
  description: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneRoleInput {
  name: String
  description: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneRoleOperatorsInput
  OR: [FilterUpdateOneRoleInput!]
  AND: [FilterUpdateOneRoleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneRoleOperatorsInput {
  description: FilterUpdateOneRoleDescriptionOperatorsInput
  _id: FilterUpdateOneRole_idOperatorsInput
  createdAt: FilterUpdateOneRoleCreatedAtOperatorsInput
}

input FilterUpdateOneRoleDescriptionOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneRole_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneRoleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneRoleInput {
  _ID_ASC
  _ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyRolePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyRoleInput {
  name: String
  description: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyRoleInput {
  name: String
  description: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyRoleOperatorsInput
  OR: [FilterUpdateManyRoleInput!]
  AND: [FilterUpdateManyRoleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyRoleOperatorsInput {
  description: FilterUpdateManyRoleDescriptionOperatorsInput
  _id: FilterUpdateManyRole_idOperatorsInput
  createdAt: FilterUpdateManyRoleCreatedAtOperatorsInput
}

input FilterUpdateManyRoleDescriptionOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyRole_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyRoleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyRoleInput {
  _ID_ASC
  _ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdRolePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Role

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneRolePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Role

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneRoleInput {
  name: String
  description: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneRoleOperatorsInput
  OR: [FilterRemoveOneRoleInput!]
  AND: [FilterRemoveOneRoleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneRoleOperatorsInput {
  description: FilterRemoveOneRoleDescriptionOperatorsInput
  _id: FilterRemoveOneRole_idOperatorsInput
  createdAt: FilterRemoveOneRoleCreatedAtOperatorsInput
}

input FilterRemoveOneRoleDescriptionOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneRole_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneRoleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneRoleInput {
  _ID_ASC
  _ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyRolePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyRoleInput {
  name: String
  description: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyRoleOperatorsInput
  OR: [FilterRemoveManyRoleInput!]
  AND: [FilterRemoveManyRoleInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyRoleOperatorsInput {
  description: FilterRemoveManyRoleDescriptionOperatorsInput
  _id: FilterRemoveManyRole_idOperatorsInput
  createdAt: FilterRemoveManyRoleCreatedAtOperatorsInput
}

input FilterRemoveManyRoleDescriptionOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyRole_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyRoleCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneSupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneSupplierInput {
  name: String!
  image: String
  company_name: String!
  vat_number: Float
  email: String!
  phone_number: Float!
  address: String!
  city: String!
  state: String!
  postal_code: String!
  country: String!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManySupplierPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Supplier!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManySupplierInput {
  name: String!
  image: String
  company_name: String!
  vat_number: Float
  email: String!
  phone_number: Float!
  address: String!
  city: String!
  state: String!
  postal_code: String!
  country: String!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdSupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdSupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneSupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneSupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneSupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneSupplierOperatorsInput
  OR: [FilterUpdateOneSupplierInput!]
  AND: [FilterUpdateOneSupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneSupplierOperatorsInput {
  name: FilterUpdateOneSupplierNameOperatorsInput
  image: FilterUpdateOneSupplierImageOperatorsInput
  company_name: FilterUpdateOneSupplierCompany_nameOperatorsInput
  vat_number: FilterUpdateOneSupplierVat_numberOperatorsInput
  email: FilterUpdateOneSupplierEmailOperatorsInput
  phone_number: FilterUpdateOneSupplierPhone_numberOperatorsInput
  address: FilterUpdateOneSupplierAddressOperatorsInput
  _id: FilterUpdateOneSupplier_idOperatorsInput
  createdAt: FilterUpdateOneSupplierCreatedAtOperatorsInput
}

input FilterUpdateOneSupplierNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneSupplierImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneSupplierCompany_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneSupplierVat_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateOneSupplierEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneSupplierPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateOneSupplierAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneSupplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneSupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneSupplierInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  COMPANY_NAME_ASC
  COMPANY_NAME_DESC
  VAT_NUMBER_ASC
  VAT_NUMBER_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManySupplierPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManySupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManySupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManySupplierOperatorsInput
  OR: [FilterUpdateManySupplierInput!]
  AND: [FilterUpdateManySupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManySupplierOperatorsInput {
  name: FilterUpdateManySupplierNameOperatorsInput
  image: FilterUpdateManySupplierImageOperatorsInput
  company_name: FilterUpdateManySupplierCompany_nameOperatorsInput
  vat_number: FilterUpdateManySupplierVat_numberOperatorsInput
  email: FilterUpdateManySupplierEmailOperatorsInput
  phone_number: FilterUpdateManySupplierPhone_numberOperatorsInput
  address: FilterUpdateManySupplierAddressOperatorsInput
  _id: FilterUpdateManySupplier_idOperatorsInput
  createdAt: FilterUpdateManySupplierCreatedAtOperatorsInput
}

input FilterUpdateManySupplierNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManySupplierImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManySupplierCompany_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManySupplierVat_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateManySupplierEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManySupplierPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateManySupplierAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManySupplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManySupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManySupplierInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  COMPANY_NAME_ASC
  COMPANY_NAME_DESC
  VAT_NUMBER_ASC
  VAT_NUMBER_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdSupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneSupplierPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Supplier

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneSupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneSupplierOperatorsInput
  OR: [FilterRemoveOneSupplierInput!]
  AND: [FilterRemoveOneSupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneSupplierOperatorsInput {
  name: FilterRemoveOneSupplierNameOperatorsInput
  image: FilterRemoveOneSupplierImageOperatorsInput
  company_name: FilterRemoveOneSupplierCompany_nameOperatorsInput
  vat_number: FilterRemoveOneSupplierVat_numberOperatorsInput
  email: FilterRemoveOneSupplierEmailOperatorsInput
  phone_number: FilterRemoveOneSupplierPhone_numberOperatorsInput
  address: FilterRemoveOneSupplierAddressOperatorsInput
  _id: FilterRemoveOneSupplier_idOperatorsInput
  createdAt: FilterRemoveOneSupplierCreatedAtOperatorsInput
}

input FilterRemoveOneSupplierNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneSupplierImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneSupplierCompany_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneSupplierVat_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveOneSupplierEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneSupplierPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveOneSupplierAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneSupplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneSupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneSupplierInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  COMPANY_NAME_ASC
  COMPANY_NAME_DESC
  VAT_NUMBER_ASC
  VAT_NUMBER_DESC
  EMAIL_ASC
  EMAIL_DESC
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManySupplierPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManySupplierInput {
  name: String
  image: String
  company_name: String
  vat_number: Float
  email: String
  phone_number: Float
  address: String
  city: String
  state: String
  postal_code: String
  country: String
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManySupplierOperatorsInput
  OR: [FilterRemoveManySupplierInput!]
  AND: [FilterRemoveManySupplierInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManySupplierOperatorsInput {
  name: FilterRemoveManySupplierNameOperatorsInput
  image: FilterRemoveManySupplierImageOperatorsInput
  company_name: FilterRemoveManySupplierCompany_nameOperatorsInput
  vat_number: FilterRemoveManySupplierVat_numberOperatorsInput
  email: FilterRemoveManySupplierEmailOperatorsInput
  phone_number: FilterRemoveManySupplierPhone_numberOperatorsInput
  address: FilterRemoveManySupplierAddressOperatorsInput
  _id: FilterRemoveManySupplier_idOperatorsInput
  createdAt: FilterRemoveManySupplierCreatedAtOperatorsInput
}

input FilterRemoveManySupplierNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManySupplierImageOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManySupplierCompany_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManySupplierVat_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveManySupplierEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManySupplierPhone_numberOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveManySupplierAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManySupplier_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManySupplierCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneTaxPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Tax

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneTaxInput {
  name: String!
  rate: Float!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyTaxPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Tax!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyTaxInput {
  name: String!
  rate: Float!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdTaxPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Tax

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneTaxPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Tax

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneTaxOperatorsInput
  OR: [FilterUpdateOneTaxInput!]
  AND: [FilterUpdateOneTaxInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneTaxOperatorsInput {
  name: FilterUpdateOneTaxNameOperatorsInput
  _id: FilterUpdateOneTax_idOperatorsInput
  createdAt: FilterUpdateOneTaxCreatedAtOperatorsInput
}

input FilterUpdateOneTaxNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneTax_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneTaxCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneTaxInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyTaxPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyTaxOperatorsInput
  OR: [FilterUpdateManyTaxInput!]
  AND: [FilterUpdateManyTaxInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyTaxOperatorsInput {
  name: FilterUpdateManyTaxNameOperatorsInput
  _id: FilterUpdateManyTax_idOperatorsInput
  createdAt: FilterUpdateManyTaxCreatedAtOperatorsInput
}

input FilterUpdateManyTaxNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyTax_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyTaxCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyTaxInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdTaxPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Tax

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneTaxPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Tax

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneTaxOperatorsInput
  OR: [FilterRemoveOneTaxInput!]
  AND: [FilterRemoveOneTaxInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneTaxOperatorsInput {
  name: FilterRemoveOneTaxNameOperatorsInput
  _id: FilterRemoveOneTax_idOperatorsInput
  createdAt: FilterRemoveOneTaxCreatedAtOperatorsInput
}

input FilterRemoveOneTaxNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneTax_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneTaxCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneTaxInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyTaxPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyTaxInput {
  name: String
  rate: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyTaxOperatorsInput
  OR: [FilterRemoveManyTaxInput!]
  AND: [FilterRemoveManyTaxInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyTaxOperatorsInput {
  name: FilterRemoveManyTaxNameOperatorsInput
  _id: FilterRemoveManyTax_idOperatorsInput
  createdAt: FilterRemoveManyTaxCreatedAtOperatorsInput
}

input FilterRemoveManyTaxNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyTax_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyTaxCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneTransferPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneTransferInput {
  reference_no: String!
  item: Float!
  total_qty: Float!
  total_tax: Float!
  total_cost: Float!
  shipping_cost: Float!
  grand_total: Float!
  paid_amount: Float!
  user: MongoID!
  from_warehouse: MongoID!
  to_warehouse: MongoID!
  product_transfers: [MongoID]!
  status: EnumTransferStatus!
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type CreateManyTransferPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Transfer!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyTransferInput {
  reference_no: String!
  item: Float!
  total_qty: Float!
  total_tax: Float!
  total_cost: Float!
  shipping_cost: Float!
  grand_total: Float!
  paid_amount: Float!
  user: MongoID!
  from_warehouse: MongoID!
  to_warehouse: MongoID!
  product_transfers: [MongoID]!
  status: EnumTransferStatus!
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdTransferPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

type UpdateOneTransferPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneTransferOperatorsInput
  OR: [FilterUpdateOneTransferInput!]
  AND: [FilterUpdateOneTransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneTransferOperatorsInput {
  reference_no: FilterUpdateOneTransferReference_noOperatorsInput
  document: FilterUpdateOneTransferDocumentOperatorsInput
  note: FilterUpdateOneTransferNoteOperatorsInput
  _id: FilterUpdateOneTransfer_idOperatorsInput
  createdAt: FilterUpdateOneTransferCreatedAtOperatorsInput
}

input FilterUpdateOneTransferReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneTransferDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneTransferNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneTransfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneTransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneTransferInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyTransferPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyTransferOperatorsInput
  OR: [FilterUpdateManyTransferInput!]
  AND: [FilterUpdateManyTransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyTransferOperatorsInput {
  reference_no: FilterUpdateManyTransferReference_noOperatorsInput
  document: FilterUpdateManyTransferDocumentOperatorsInput
  note: FilterUpdateManyTransferNoteOperatorsInput
  _id: FilterUpdateManyTransfer_idOperatorsInput
  createdAt: FilterUpdateManyTransferCreatedAtOperatorsInput
}

input FilterUpdateManyTransferReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyTransferDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyTransferNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyTransfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyTransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyTransferInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdTransferPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneTransferPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Transfer

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneTransferOperatorsInput
  OR: [FilterRemoveOneTransferInput!]
  AND: [FilterRemoveOneTransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneTransferOperatorsInput {
  reference_no: FilterRemoveOneTransferReference_noOperatorsInput
  document: FilterRemoveOneTransferDocumentOperatorsInput
  note: FilterRemoveOneTransferNoteOperatorsInput
  _id: FilterRemoveOneTransfer_idOperatorsInput
  createdAt: FilterRemoveOneTransferCreatedAtOperatorsInput
}

input FilterRemoveOneTransferReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneTransferDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneTransferNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneTransfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneTransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneTransferInput {
  _ID_ASC
  _ID_DESC
  REFERENCE_NO_ASC
  REFERENCE_NO_DESC
  DOCUMENT_ASC
  DOCUMENT_DESC
  NOTE_ASC
  NOTE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyTransferPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyTransferInput {
  reference_no: String
  item: Float
  total_qty: Float
  total_tax: Float
  total_cost: Float
  shipping_cost: Float
  grand_total: Float
  paid_amount: Float
  user: MongoID
  from_warehouse: MongoID
  to_warehouse: MongoID
  product_transfers: [MongoID]
  status: EnumTransferStatus
  document: String
  note: String
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyTransferOperatorsInput
  OR: [FilterRemoveManyTransferInput!]
  AND: [FilterRemoveManyTransferInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyTransferOperatorsInput {
  reference_no: FilterRemoveManyTransferReference_noOperatorsInput
  document: FilterRemoveManyTransferDocumentOperatorsInput
  note: FilterRemoveManyTransferNoteOperatorsInput
  _id: FilterRemoveManyTransfer_idOperatorsInput
  createdAt: FilterRemoveManyTransferCreatedAtOperatorsInput
}

input FilterRemoveManyTransferReference_noOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyTransferDocumentOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyTransferNoteOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyTransfer_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyTransferCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneUnitPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Unit

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneUnitInput {
  unit_name: String!
  unit_code: String!
  base_unit: String!
  operator: String!
  operation_value: Float!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyUnitPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Unit!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyUnitInput {
  unit_name: String!
  unit_code: String!
  base_unit: String!
  operator: String!
  operation_value: Float!
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdUnitPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Unit

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneUnitPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Unit

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneUnitOperatorsInput
  OR: [FilterUpdateOneUnitInput!]
  AND: [FilterUpdateOneUnitInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneUnitOperatorsInput {
  unit_name: FilterUpdateOneUnitUnit_nameOperatorsInput
  unit_code: FilterUpdateOneUnitUnit_codeOperatorsInput
  _id: FilterUpdateOneUnit_idOperatorsInput
  createdAt: FilterUpdateOneUnitCreatedAtOperatorsInput
}

input FilterUpdateOneUnitUnit_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneUnitUnit_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneUnit_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneUnitCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneUnitInput {
  _ID_ASC
  _ID_DESC
  UNIT_NAME_ASC
  UNIT_NAME_DESC
  UNIT_CODE_ASC
  UNIT_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyUnitPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyUnitOperatorsInput
  OR: [FilterUpdateManyUnitInput!]
  AND: [FilterUpdateManyUnitInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyUnitOperatorsInput {
  unit_name: FilterUpdateManyUnitUnit_nameOperatorsInput
  unit_code: FilterUpdateManyUnitUnit_codeOperatorsInput
  _id: FilterUpdateManyUnit_idOperatorsInput
  createdAt: FilterUpdateManyUnitCreatedAtOperatorsInput
}

input FilterUpdateManyUnitUnit_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyUnitUnit_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyUnit_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyUnitCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyUnitInput {
  _ID_ASC
  _ID_DESC
  UNIT_NAME_ASC
  UNIT_NAME_DESC
  UNIT_CODE_ASC
  UNIT_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdUnitPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Unit

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneUnitPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Unit

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneUnitOperatorsInput
  OR: [FilterRemoveOneUnitInput!]
  AND: [FilterRemoveOneUnitInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneUnitOperatorsInput {
  unit_name: FilterRemoveOneUnitUnit_nameOperatorsInput
  unit_code: FilterRemoveOneUnitUnit_codeOperatorsInput
  _id: FilterRemoveOneUnit_idOperatorsInput
  createdAt: FilterRemoveOneUnitCreatedAtOperatorsInput
}

input FilterRemoveOneUnitUnit_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneUnitUnit_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneUnit_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneUnitCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneUnitInput {
  _ID_ASC
  _ID_DESC
  UNIT_NAME_ASC
  UNIT_NAME_DESC
  UNIT_CODE_ASC
  UNIT_CODE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyUnitPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyUnitInput {
  unit_name: String
  unit_code: String
  base_unit: String
  operator: String
  operation_value: Float
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyUnitOperatorsInput
  OR: [FilterRemoveManyUnitInput!]
  AND: [FilterRemoveManyUnitInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyUnitOperatorsInput {
  unit_name: FilterRemoveManyUnitUnit_nameOperatorsInput
  unit_code: FilterRemoveManyUnitUnit_codeOperatorsInput
  _id: FilterRemoveManyUnit_idOperatorsInput
  createdAt: FilterRemoveManyUnitCreatedAtOperatorsInput
}

input FilterRemoveManyUnitUnit_nameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyUnitUnit_codeOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyUnit_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyUnitCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneUserPayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneUserInput {
  name: String!
  password: String!
  role: MongoID!
  personnel: MongoID!
  personnelModel: EnumUserPersonnelModel!
  warehouses: [MongoID]
  is_active: Boolean!
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

type CreateManyUserPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [User!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyUserInput {
  name: String!
  password: String!
  role: MongoID!
  personnel: MongoID!
  personnelModel: EnumUserPersonnelModel!
  warehouses: [MongoID]
  is_active: Boolean!
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdUserPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneUserPayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneUserOperatorsInput
  OR: [FilterUpdateOneUserInput!]
  AND: [FilterUpdateOneUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneUserOperatorsInput {
  _id: FilterUpdateOneUser_idOperatorsInput
  createdAt: FilterUpdateOneUserCreatedAtOperatorsInput
}

input FilterUpdateOneUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneUserCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneUserInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyUserPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyUserOperatorsInput
  OR: [FilterUpdateManyUserInput!]
  AND: [FilterUpdateManyUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyUserOperatorsInput {
  _id: FilterUpdateManyUser_idOperatorsInput
  createdAt: FilterUpdateManyUserCreatedAtOperatorsInput
}

input FilterUpdateManyUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyUserCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyUserInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdUserPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneUserPayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: User

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneUserOperatorsInput
  OR: [FilterRemoveOneUserInput!]
  AND: [FilterRemoveOneUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneUserOperatorsInput {
  _id: FilterRemoveOneUser_idOperatorsInput
  createdAt: FilterRemoveOneUserCreatedAtOperatorsInput
}

input FilterRemoveOneUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneUserCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneUserInput {
  _ID_ASC
  _ID_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyUserPayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyUserInput {
  name: String
  password: String
  role: MongoID
  personnel: MongoID
  personnelModel: EnumUserPersonnelModel
  warehouses: [MongoID]
  is_active: Boolean
  is_deleted: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyUserOperatorsInput
  OR: [FilterRemoveManyUserInput!]
  AND: [FilterRemoveManyUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyUserOperatorsInput {
  _id: FilterRemoveManyUser_idOperatorsInput
  createdAt: FilterRemoveManyUserCreatedAtOperatorsInput
}

input FilterRemoveManyUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyUserCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneValuePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Value

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneValueInput {
  name: String!
  attribute: MongoID!
  updatedAt: Date
  createdAt: Date
}

type CreateManyValuePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Value!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyValueInput {
  name: String!
  attribute: MongoID!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdValuePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Value

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdValueInput {
  name: String
  attribute: MongoID
  updatedAt: Date
  createdAt: Date
}

type UpdateOneValuePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Value

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneValueInput {
  name: String
  attribute: MongoID
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneValueInput {
  name: String
  attribute: MongoID
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneValueOperatorsInput
  OR: [FilterUpdateOneValueInput!]
  AND: [FilterUpdateOneValueInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneValueOperatorsInput {
  name: FilterUpdateOneValueNameOperatorsInput
  _id: FilterUpdateOneValue_idOperatorsInput
  createdAt: FilterUpdateOneValueCreatedAtOperatorsInput
}

input FilterUpdateOneValueNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneValue_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneValueCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneValueInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyValuePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyValueInput {
  name: String
  attribute: MongoID
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyValueInput {
  name: String
  attribute: MongoID
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyValueOperatorsInput
  OR: [FilterUpdateManyValueInput!]
  AND: [FilterUpdateManyValueInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyValueOperatorsInput {
  name: FilterUpdateManyValueNameOperatorsInput
  _id: FilterUpdateManyValue_idOperatorsInput
  createdAt: FilterUpdateManyValueCreatedAtOperatorsInput
}

input FilterUpdateManyValueNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyValue_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyValueCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyValueInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdValuePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Value

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneValuePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Value

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneValueInput {
  name: String
  attribute: MongoID
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneValueOperatorsInput
  OR: [FilterRemoveOneValueInput!]
  AND: [FilterRemoveOneValueInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneValueOperatorsInput {
  name: FilterRemoveOneValueNameOperatorsInput
  _id: FilterRemoveOneValue_idOperatorsInput
  createdAt: FilterRemoveOneValueCreatedAtOperatorsInput
}

input FilterRemoveOneValueNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneValue_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneValueCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneValueInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyValuePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyValueInput {
  name: String
  attribute: MongoID
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyValueOperatorsInput
  OR: [FilterRemoveManyValueInput!]
  AND: [FilterRemoveManyValueInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyValueOperatorsInput {
  name: FilterRemoveManyValueNameOperatorsInput
  _id: FilterRemoveManyValue_idOperatorsInput
  createdAt: FilterRemoveManyValueCreatedAtOperatorsInput
}

input FilterRemoveManyValueNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyValue_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyValueCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

type CreateOneWarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Created document"""
  record: Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateOneWarehouseInput {
  name: String!
  email: String!
  address: String!
  phone: Float!
  product_variants: [MongoID]
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type CreateManyWarehousePayload {
  """Documents IDs"""
  recordIds: [MongoID!]!

  """Created documents"""
  records: [Warehouse!]

  """Number of created documents"""
  createdCount: Int!

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input CreateManyWarehouseInput {
  name: String!
  email: String!
  address: String!
  phone: Float!
  product_variants: [MongoID]
  is_active: Boolean!
  updatedAt: Date
  createdAt: Date
}

type UpdateByIdWarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateByIdWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

type UpdateOneWarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Updated document"""
  record: Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateOneWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateOneWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneWarehouseOperatorsInput
  OR: [FilterUpdateOneWarehouseInput!]
  AND: [FilterUpdateOneWarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneWarehouseOperatorsInput {
  name: FilterUpdateOneWarehouseNameOperatorsInput
  email: FilterUpdateOneWarehouseEmailOperatorsInput
  address: FilterUpdateOneWarehouseAddressOperatorsInput
  phone: FilterUpdateOneWarehousePhoneOperatorsInput
  _id: FilterUpdateOneWarehouse_idOperatorsInput
  createdAt: FilterUpdateOneWarehouseCreatedAtOperatorsInput
}

input FilterUpdateOneWarehouseNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneWarehouseEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneWarehouseAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateOneWarehousePhoneOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateOneWarehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateOneWarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateOneWarehouseInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  PHONE_ASC
  PHONE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type UpdateManyWarehousePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input UpdateManyWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  updatedAt: Date
  createdAt: Date
}

""""""
input FilterUpdateManyWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyWarehouseOperatorsInput
  OR: [FilterUpdateManyWarehouseInput!]
  AND: [FilterUpdateManyWarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyWarehouseOperatorsInput {
  name: FilterUpdateManyWarehouseNameOperatorsInput
  email: FilterUpdateManyWarehouseEmailOperatorsInput
  address: FilterUpdateManyWarehouseAddressOperatorsInput
  phone: FilterUpdateManyWarehousePhoneOperatorsInput
  _id: FilterUpdateManyWarehouse_idOperatorsInput
  createdAt: FilterUpdateManyWarehouseCreatedAtOperatorsInput
}

input FilterUpdateManyWarehouseNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyWarehouseEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyWarehouseAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterUpdateManyWarehousePhoneOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterUpdateManyWarehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterUpdateManyWarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortUpdateManyWarehouseInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  PHONE_ASC
  PHONE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveByIdWarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

type RemoveOneWarehousePayload {
  """Document ID"""
  recordId: MongoID

  """Removed document"""
  record: Warehouse

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveOneWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneWarehouseOperatorsInput
  OR: [FilterRemoveOneWarehouseInput!]
  AND: [FilterRemoveOneWarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneWarehouseOperatorsInput {
  name: FilterRemoveOneWarehouseNameOperatorsInput
  email: FilterRemoveOneWarehouseEmailOperatorsInput
  address: FilterRemoveOneWarehouseAddressOperatorsInput
  phone: FilterRemoveOneWarehousePhoneOperatorsInput
  _id: FilterRemoveOneWarehouse_idOperatorsInput
  createdAt: FilterRemoveOneWarehouseCreatedAtOperatorsInput
}

input FilterRemoveOneWarehouseNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneWarehouseEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneWarehouseAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveOneWarehousePhoneOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveOneWarehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveOneWarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}

enum SortRemoveOneWarehouseInput {
  _ID_ASC
  _ID_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  PHONE_ASC
  PHONE_DESC
  CREATEDAT_ASC
  CREATEDAT_DESC
  CREATEDAT__UPDATEDAT_ASC
  CREATEDAT__UPDATEDAT_DESC
}

type RemoveManyWarehousePayload {
  """Affected documents number"""
  numAffected: Int

  """
  Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response.
  """
  error: ErrorInterface
}

""""""
input FilterRemoveManyWarehouseInput {
  name: String
  email: String
  address: String
  phone: Float
  product_variants: [MongoID]
  is_active: Boolean
  _id: MongoID
  updatedAt: Date
  createdAt: Date

  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyWarehouseOperatorsInput
  OR: [FilterRemoveManyWarehouseInput!]
  AND: [FilterRemoveManyWarehouseInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyWarehouseOperatorsInput {
  name: FilterRemoveManyWarehouseNameOperatorsInput
  email: FilterRemoveManyWarehouseEmailOperatorsInput
  address: FilterRemoveManyWarehouseAddressOperatorsInput
  phone: FilterRemoveManyWarehousePhoneOperatorsInput
  _id: FilterRemoveManyWarehouse_idOperatorsInput
  createdAt: FilterRemoveManyWarehouseCreatedAtOperatorsInput
}

input FilterRemoveManyWarehouseNameOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyWarehouseEmailOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyWarehouseAddressOperatorsInput {
  gt: String
  gte: String
  lt: String
  lte: String
  ne: String
  in: [String]
  nin: [String]
  regex: RegExpAsString
  exists: Boolean
}

input FilterRemoveManyWarehousePhoneOperatorsInput {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  ne: Float
  in: [Float]
  nin: [Float]
  exists: Boolean
}

input FilterRemoveManyWarehouse_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

input FilterRemoveManyWarehouseCreatedAtOperatorsInput {
  gt: Date
  gte: Date
  lt: Date
  lte: Date
  ne: Date
  in: [Date]
  nin: [Date]
  exists: Boolean
}
